// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: imgDetails.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_imgDetails_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_imgDetails_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_imgDetails_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_imgDetails_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_imgDetails_2eproto;
class ImgDetails;
struct ImgDetailsDefaultTypeInternal;
extern ImgDetailsDefaultTypeInternal _ImgDetails_default_instance_;
class malwareClassifierAnalysis;
struct malwareClassifierAnalysisDefaultTypeInternal;
extern malwareClassifierAnalysisDefaultTypeInternal _malwareClassifierAnalysis_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google


// ===================================================================


// -------------------------------------------------------------------

class malwareClassifierAnalysis final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:malwareClassifierAnalysis) */ {
 public:
  inline malwareClassifierAnalysis() : malwareClassifierAnalysis(nullptr) {}
  ~malwareClassifierAnalysis() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR malwareClassifierAnalysis(
      ::google::protobuf::internal::ConstantInitialized);

  inline malwareClassifierAnalysis(const malwareClassifierAnalysis& from) : malwareClassifierAnalysis(nullptr, from) {}
  inline malwareClassifierAnalysis(malwareClassifierAnalysis&& from) noexcept
      : malwareClassifierAnalysis(nullptr, std::move(from)) {}
  inline malwareClassifierAnalysis& operator=(const malwareClassifierAnalysis& from) {
    CopyFrom(from);
    return *this;
  }
  inline malwareClassifierAnalysis& operator=(malwareClassifierAnalysis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const malwareClassifierAnalysis& default_instance() {
    return *internal_default_instance();
  }
  static inline const malwareClassifierAnalysis* internal_default_instance() {
    return reinterpret_cast<const malwareClassifierAnalysis*>(
        &_malwareClassifierAnalysis_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(malwareClassifierAnalysis& a, malwareClassifierAnalysis& b) { a.Swap(&b); }
  inline void Swap(malwareClassifierAnalysis* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(malwareClassifierAnalysis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  malwareClassifierAnalysis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<malwareClassifierAnalysis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const malwareClassifierAnalysis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const malwareClassifierAnalysis& from) { malwareClassifierAnalysis::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(malwareClassifierAnalysis* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "malwareClassifierAnalysis"; }

 protected:
  explicit malwareClassifierAnalysis(::google::protobuf::Arena* arena);
  malwareClassifierAnalysis(::google::protobuf::Arena* arena, const malwareClassifierAnalysis& from);
  malwareClassifierAnalysis(::google::protobuf::Arena* arena, malwareClassifierAnalysis&& from) noexcept
      : malwareClassifierAnalysis(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMultifamilyResultFieldNumber = 1,
    kBenignProbFieldNumber = 2,
    kDownloaderInstallerDropperProbFieldNumber = 3,
    kFlooderInfectorVirusProbFieldNumber = 4,
    kRansomwareProbFieldNumber = 5,
    kSpywareStealerProbFieldNumber = 6,
    kWormProbFieldNumber = 7,
    kBackdoorProbFieldNumber = 8,
    kGenericProbFieldNumber = 9,
    kImportProbFieldNumber = 10,
    kFeatureProbFieldNumber = 11,
    kCombineProbFieldNumber = 12,
    kBinaryModelResultFieldNumber = 13,
  };
  // int32 multifamilyResult = 1;
  void clear_multifamilyresult() ;
  ::int32_t multifamilyresult() const;
  void set_multifamilyresult(::int32_t value);

  private:
  ::int32_t _internal_multifamilyresult() const;
  void _internal_set_multifamilyresult(::int32_t value);

  public:
  // float BenignProb = 2;
  void clear_benignprob() ;
  float benignprob() const;
  void set_benignprob(float value);

  private:
  float _internal_benignprob() const;
  void _internal_set_benignprob(float value);

  public:
  // float DownloaderInstallerDropperProb = 3;
  void clear_downloaderinstallerdropperprob() ;
  float downloaderinstallerdropperprob() const;
  void set_downloaderinstallerdropperprob(float value);

  private:
  float _internal_downloaderinstallerdropperprob() const;
  void _internal_set_downloaderinstallerdropperprob(float value);

  public:
  // float FlooderInfectorVirusProb = 4;
  void clear_flooderinfectorvirusprob() ;
  float flooderinfectorvirusprob() const;
  void set_flooderinfectorvirusprob(float value);

  private:
  float _internal_flooderinfectorvirusprob() const;
  void _internal_set_flooderinfectorvirusprob(float value);

  public:
  // float RansomwareProb = 5;
  void clear_ransomwareprob() ;
  float ransomwareprob() const;
  void set_ransomwareprob(float value);

  private:
  float _internal_ransomwareprob() const;
  void _internal_set_ransomwareprob(float value);

  public:
  // float SpywareStealerProb = 6;
  void clear_spywarestealerprob() ;
  float spywarestealerprob() const;
  void set_spywarestealerprob(float value);

  private:
  float _internal_spywarestealerprob() const;
  void _internal_set_spywarestealerprob(float value);

  public:
  // float WormProb = 7;
  void clear_wormprob() ;
  float wormprob() const;
  void set_wormprob(float value);

  private:
  float _internal_wormprob() const;
  void _internal_set_wormprob(float value);

  public:
  // float BackdoorProb = 8;
  void clear_backdoorprob() ;
  float backdoorprob() const;
  void set_backdoorprob(float value);

  private:
  float _internal_backdoorprob() const;
  void _internal_set_backdoorprob(float value);

  public:
  // float GenericProb = 9;
  void clear_genericprob() ;
  float genericprob() const;
  void set_genericprob(float value);

  private:
  float _internal_genericprob() const;
  void _internal_set_genericprob(float value);

  public:
  // float ImportProb = 10;
  void clear_importprob() ;
  float importprob() const;
  void set_importprob(float value);

  private:
  float _internal_importprob() const;
  void _internal_set_importprob(float value);

  public:
  // float featureProb = 11;
  void clear_featureprob() ;
  float featureprob() const;
  void set_featureprob(float value);

  private:
  float _internal_featureprob() const;
  void _internal_set_featureprob(float value);

  public:
  // float combineProb = 12;
  void clear_combineprob() ;
  float combineprob() const;
  void set_combineprob(float value);

  private:
  float _internal_combineprob() const;
  void _internal_set_combineprob(float value);

  public:
  // int32 binaryModelResult = 13;
  void clear_binarymodelresult() ;
  ::int32_t binarymodelresult() const;
  void set_binarymodelresult(::int32_t value);

  private:
  ::int32_t _internal_binarymodelresult() const;
  void _internal_set_binarymodelresult(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:malwareClassifierAnalysis)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t multifamilyresult_;
    float benignprob_;
    float downloaderinstallerdropperprob_;
    float flooderinfectorvirusprob_;
    float ransomwareprob_;
    float spywarestealerprob_;
    float wormprob_;
    float backdoorprob_;
    float genericprob_;
    float importprob_;
    float featureprob_;
    float combineprob_;
    ::int32_t binarymodelresult_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_imgDetails_2eproto;
};
// -------------------------------------------------------------------

class ImgDetails final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ImgDetails) */ {
 public:
  inline ImgDetails() : ImgDetails(nullptr) {}
  ~ImgDetails() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImgDetails(
      ::google::protobuf::internal::ConstantInitialized);

  inline ImgDetails(const ImgDetails& from) : ImgDetails(nullptr, from) {}
  inline ImgDetails(ImgDetails&& from) noexcept
      : ImgDetails(nullptr, std::move(from)) {}
  inline ImgDetails& operator=(const ImgDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImgDetails& operator=(ImgDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImgDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImgDetails* internal_default_instance() {
    return reinterpret_cast<const ImgDetails*>(
        &_ImgDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ImgDetails& a, ImgDetails& b) { a.Swap(&b); }
  inline void Swap(ImgDetails* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImgDetails* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImgDetails* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ImgDetails>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImgDetails& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImgDetails& from) { ImgDetails::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImgDetails* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ImgDetails"; }

 protected:
  explicit ImgDetails(::google::protobuf::Arena* arena);
  ImgDetails(::google::protobuf::Arena* arena, const ImgDetails& from);
  ImgDetails(::google::protobuf::Arena* arena, ImgDetails&& from) noexcept
      : ImgDetails(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPublisherFieldNumber = 1,
    kCataFileFieldNumber = 2,
    kTimeStampFieldNumber = 3,
    kVSignChainversionFieldNumber = 4,
    kDigestAlgorithmFieldNumber = 5,
    kImphaseHashFieldNumber = 6,
    kImphashStringFieldNumber = 7,
    kPermissionFieldNumber = 8,
    kCompanyFieldNumber = 9,
    kDescriptionFieldNumber = 10,
    kProductFieldNumber = 11,
    kInternalNameFieldNumber = 12,
    kCopyRightsFieldNumber = 13,
    kOrgfilenameFieldNumber = 14,
    kProductVersionFieldNumber = 15,
    kFileVersionFieldNumber = 16,
    kMimetypeFieldNumber = 17,
    kFiletypeextFieldNumber = 18,
    kWritetimeFieldNumber = 19,
    kAccesstimeFieldNumber = 20,
    kCreatetimeFieldNumber = 21,
    kMD5LEBufferFieldNumber = 22,
    kSHA1BufferFieldNumber = 23,
    kSHA256BufferFieldNumber = 24,
    kSHA512BufferFieldNumber = 25,
    kStatusFieldNumber = 26,
    kThumbprintFieldNumber = 27,
    kSignAlgFieldNumber = 28,
    kFilePathFieldNumber = 42,
    kImportFunctionstringFieldNumber = 45,
    kProperFilePathFieldNumber = 47,
    kPatternstringFieldNumber = 48,
    kErrorCodestringFieldNumber = 50,
    kImportArrayFieldNumber = 51,
    kFeatureArrayFieldNumber = 52,
    kMCAnalysisFieldNumber = 44,
    kFileSizeFieldNumber = 29,
    kSigntypeFieldNumber = 30,
    kNumberofCertChainsFieldNumber = 31,
    kCharacteristicsFieldNumber = 32,
    kFiletypeFieldNumber = 33,
    kBinarytimeFieldNumber = 34,
    kBinaryTypeFieldNumber = 35,
    kMachineTypeFieldNumber = 36,
    kIsMalwareFieldNumber = 37,
    kConfidenceFieldNumber = 38,
    kImpMalwareFieldNumber = 39,
    kFeatureMalwareFieldNumber = 40,
    kErrorCodeFieldNumber = 43,
    kPatternOffsetFieldNumber = 49,
  };
  // bytes publisher = 1;
  void clear_publisher() ;
  const std::string& publisher() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_publisher(Arg_&& arg, Args_... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* value);

  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(
      const std::string& value);
  std::string* _internal_mutable_publisher();

  public:
  // bytes CataFile = 2;
  void clear_catafile() ;
  const std::string& catafile() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_catafile(Arg_&& arg, Args_... args);
  std::string* mutable_catafile();
  PROTOBUF_NODISCARD std::string* release_catafile();
  void set_allocated_catafile(std::string* value);

  private:
  const std::string& _internal_catafile() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_catafile(
      const std::string& value);
  std::string* _internal_mutable_catafile();

  public:
  // bytes TimeStamp = 3;
  void clear_timestamp() ;
  const std::string& timestamp() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_timestamp(Arg_&& arg, Args_... args);
  std::string* mutable_timestamp();
  PROTOBUF_NODISCARD std::string* release_timestamp();
  void set_allocated_timestamp(std::string* value);

  private:
  const std::string& _internal_timestamp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_timestamp(
      const std::string& value);
  std::string* _internal_mutable_timestamp();

  public:
  // bytes VSignChainversion = 4;
  void clear_vsignchainversion() ;
  const std::string& vsignchainversion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_vsignchainversion(Arg_&& arg, Args_... args);
  std::string* mutable_vsignchainversion();
  PROTOBUF_NODISCARD std::string* release_vsignchainversion();
  void set_allocated_vsignchainversion(std::string* value);

  private:
  const std::string& _internal_vsignchainversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vsignchainversion(
      const std::string& value);
  std::string* _internal_mutable_vsignchainversion();

  public:
  // bytes DigestAlgorithm = 5;
  void clear_digestalgorithm() ;
  const std::string& digestalgorithm() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_digestalgorithm(Arg_&& arg, Args_... args);
  std::string* mutable_digestalgorithm();
  PROTOBUF_NODISCARD std::string* release_digestalgorithm();
  void set_allocated_digestalgorithm(std::string* value);

  private:
  const std::string& _internal_digestalgorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_digestalgorithm(
      const std::string& value);
  std::string* _internal_mutable_digestalgorithm();

  public:
  // bytes Imphase_hash = 6;
  void clear_imphase_hash() ;
  const std::string& imphase_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_imphase_hash(Arg_&& arg, Args_... args);
  std::string* mutable_imphase_hash();
  PROTOBUF_NODISCARD std::string* release_imphase_hash();
  void set_allocated_imphase_hash(std::string* value);

  private:
  const std::string& _internal_imphase_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imphase_hash(
      const std::string& value);
  std::string* _internal_mutable_imphase_hash();

  public:
  // bytes imphash_string = 7;
  void clear_imphash_string() ;
  const std::string& imphash_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_imphash_string(Arg_&& arg, Args_... args);
  std::string* mutable_imphash_string();
  PROTOBUF_NODISCARD std::string* release_imphash_string();
  void set_allocated_imphash_string(std::string* value);

  private:
  const std::string& _internal_imphash_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_imphash_string(
      const std::string& value);
  std::string* _internal_mutable_imphash_string();

  public:
  // bytes Permission = 8;
  void clear_permission() ;
  const std::string& permission() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_permission(Arg_&& arg, Args_... args);
  std::string* mutable_permission();
  PROTOBUF_NODISCARD std::string* release_permission();
  void set_allocated_permission(std::string* value);

  private:
  const std::string& _internal_permission() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_permission(
      const std::string& value);
  std::string* _internal_mutable_permission();

  public:
  // bytes Company = 9;
  void clear_company() ;
  const std::string& company() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_company(Arg_&& arg, Args_... args);
  std::string* mutable_company();
  PROTOBUF_NODISCARD std::string* release_company();
  void set_allocated_company(std::string* value);

  private:
  const std::string& _internal_company() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_company(
      const std::string& value);
  std::string* _internal_mutable_company();

  public:
  // bytes Description = 10;
  void clear_description() ;
  const std::string& description() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_description(Arg_&& arg, Args_... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* value);

  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(
      const std::string& value);
  std::string* _internal_mutable_description();

  public:
  // bytes Product = 11;
  void clear_product() ;
  const std::string& product() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_product(Arg_&& arg, Args_... args);
  std::string* mutable_product();
  PROTOBUF_NODISCARD std::string* release_product();
  void set_allocated_product(std::string* value);

  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(
      const std::string& value);
  std::string* _internal_mutable_product();

  public:
  // bytes InternalName = 12;
  void clear_internalname() ;
  const std::string& internalname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_internalname(Arg_&& arg, Args_... args);
  std::string* mutable_internalname();
  PROTOBUF_NODISCARD std::string* release_internalname();
  void set_allocated_internalname(std::string* value);

  private:
  const std::string& _internal_internalname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_internalname(
      const std::string& value);
  std::string* _internal_mutable_internalname();

  public:
  // bytes CopyRights = 13;
  void clear_copyrights() ;
  const std::string& copyrights() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_copyrights(Arg_&& arg, Args_... args);
  std::string* mutable_copyrights();
  PROTOBUF_NODISCARD std::string* release_copyrights();
  void set_allocated_copyrights(std::string* value);

  private:
  const std::string& _internal_copyrights() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_copyrights(
      const std::string& value);
  std::string* _internal_mutable_copyrights();

  public:
  // bytes Orgfilename = 14;
  void clear_orgfilename() ;
  const std::string& orgfilename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_orgfilename(Arg_&& arg, Args_... args);
  std::string* mutable_orgfilename();
  PROTOBUF_NODISCARD std::string* release_orgfilename();
  void set_allocated_orgfilename(std::string* value);

  private:
  const std::string& _internal_orgfilename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_orgfilename(
      const std::string& value);
  std::string* _internal_mutable_orgfilename();

  public:
  // bytes ProductVersion = 15;
  void clear_productversion() ;
  const std::string& productversion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_productversion(Arg_&& arg, Args_... args);
  std::string* mutable_productversion();
  PROTOBUF_NODISCARD std::string* release_productversion();
  void set_allocated_productversion(std::string* value);

  private:
  const std::string& _internal_productversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_productversion(
      const std::string& value);
  std::string* _internal_mutable_productversion();

  public:
  // bytes FileVersion = 16;
  void clear_fileversion() ;
  const std::string& fileversion() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_fileversion(Arg_&& arg, Args_... args);
  std::string* mutable_fileversion();
  PROTOBUF_NODISCARD std::string* release_fileversion();
  void set_allocated_fileversion(std::string* value);

  private:
  const std::string& _internal_fileversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fileversion(
      const std::string& value);
  std::string* _internal_mutable_fileversion();

  public:
  // bytes Mimetype = 17;
  void clear_mimetype() ;
  const std::string& mimetype() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mimetype(Arg_&& arg, Args_... args);
  std::string* mutable_mimetype();
  PROTOBUF_NODISCARD std::string* release_mimetype();
  void set_allocated_mimetype(std::string* value);

  private:
  const std::string& _internal_mimetype() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mimetype(
      const std::string& value);
  std::string* _internal_mutable_mimetype();

  public:
  // bytes filetypeext = 18;
  void clear_filetypeext() ;
  const std::string& filetypeext() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filetypeext(Arg_&& arg, Args_... args);
  std::string* mutable_filetypeext();
  PROTOBUF_NODISCARD std::string* release_filetypeext();
  void set_allocated_filetypeext(std::string* value);

  private:
  const std::string& _internal_filetypeext() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filetypeext(
      const std::string& value);
  std::string* _internal_mutable_filetypeext();

  public:
  // bytes Writetime = 19;
  void clear_writetime() ;
  const std::string& writetime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_writetime(Arg_&& arg, Args_... args);
  std::string* mutable_writetime();
  PROTOBUF_NODISCARD std::string* release_writetime();
  void set_allocated_writetime(std::string* value);

  private:
  const std::string& _internal_writetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_writetime(
      const std::string& value);
  std::string* _internal_mutable_writetime();

  public:
  // bytes Accesstime = 20;
  void clear_accesstime() ;
  const std::string& accesstime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_accesstime(Arg_&& arg, Args_... args);
  std::string* mutable_accesstime();
  PROTOBUF_NODISCARD std::string* release_accesstime();
  void set_allocated_accesstime(std::string* value);

  private:
  const std::string& _internal_accesstime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstime(
      const std::string& value);
  std::string* _internal_mutable_accesstime();

  public:
  // bytes Createtime = 21;
  void clear_createtime() ;
  const std::string& createtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_createtime(Arg_&& arg, Args_... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* value);

  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(
      const std::string& value);
  std::string* _internal_mutable_createtime();

  public:
  // bytes MD5LE_buffer = 22;
  void clear_md5le_buffer() ;
  const std::string& md5le_buffer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_md5le_buffer(Arg_&& arg, Args_... args);
  std::string* mutable_md5le_buffer();
  PROTOBUF_NODISCARD std::string* release_md5le_buffer();
  void set_allocated_md5le_buffer(std::string* value);

  private:
  const std::string& _internal_md5le_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_md5le_buffer(
      const std::string& value);
  std::string* _internal_mutable_md5le_buffer();

  public:
  // bytes SHA1_buffer = 23;
  void clear_sha1_buffer() ;
  const std::string& sha1_buffer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sha1_buffer(Arg_&& arg, Args_... args);
  std::string* mutable_sha1_buffer();
  PROTOBUF_NODISCARD std::string* release_sha1_buffer();
  void set_allocated_sha1_buffer(std::string* value);

  private:
  const std::string& _internal_sha1_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha1_buffer(
      const std::string& value);
  std::string* _internal_mutable_sha1_buffer();

  public:
  // bytes SHA256_buffer = 24;
  void clear_sha256_buffer() ;
  const std::string& sha256_buffer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sha256_buffer(Arg_&& arg, Args_... args);
  std::string* mutable_sha256_buffer();
  PROTOBUF_NODISCARD std::string* release_sha256_buffer();
  void set_allocated_sha256_buffer(std::string* value);

  private:
  const std::string& _internal_sha256_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha256_buffer(
      const std::string& value);
  std::string* _internal_mutable_sha256_buffer();

  public:
  // bytes SHA512_buffer = 25;
  void clear_sha512_buffer() ;
  const std::string& sha512_buffer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sha512_buffer(Arg_&& arg, Args_... args);
  std::string* mutable_sha512_buffer();
  PROTOBUF_NODISCARD std::string* release_sha512_buffer();
  void set_allocated_sha512_buffer(std::string* value);

  private:
  const std::string& _internal_sha512_buffer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha512_buffer(
      const std::string& value);
  std::string* _internal_mutable_sha512_buffer();

  public:
  // bytes status = 26;
  void clear_status() ;
  const std::string& status() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_status(Arg_&& arg, Args_... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* value);

  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(
      const std::string& value);
  std::string* _internal_mutable_status();

  public:
  // bytes thumbprint = 27;
  void clear_thumbprint() ;
  const std::string& thumbprint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_thumbprint(Arg_&& arg, Args_... args);
  std::string* mutable_thumbprint();
  PROTOBUF_NODISCARD std::string* release_thumbprint();
  void set_allocated_thumbprint(std::string* value);

  private:
  const std::string& _internal_thumbprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbprint(
      const std::string& value);
  std::string* _internal_mutable_thumbprint();

  public:
  // bytes sign_alg = 28;
  void clear_sign_alg() ;
  const std::string& sign_alg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sign_alg(Arg_&& arg, Args_... args);
  std::string* mutable_sign_alg();
  PROTOBUF_NODISCARD std::string* release_sign_alg();
  void set_allocated_sign_alg(std::string* value);

  private:
  const std::string& _internal_sign_alg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign_alg(
      const std::string& value);
  std::string* _internal_mutable_sign_alg();

  public:
  // bytes filePath = 42;
  void clear_filepath() ;
  const std::string& filepath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filepath(Arg_&& arg, Args_... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* value);

  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(
      const std::string& value);
  std::string* _internal_mutable_filepath();

  public:
  // bytes importFunctionstring = 45;
  void clear_importfunctionstring() ;
  const std::string& importfunctionstring() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_importfunctionstring(Arg_&& arg, Args_... args);
  std::string* mutable_importfunctionstring();
  PROTOBUF_NODISCARD std::string* release_importfunctionstring();
  void set_allocated_importfunctionstring(std::string* value);

  private:
  const std::string& _internal_importfunctionstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_importfunctionstring(
      const std::string& value);
  std::string* _internal_mutable_importfunctionstring();

  public:
  // bytes properFilePath = 47;
  void clear_properfilepath() ;
  const std::string& properfilepath() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_properfilepath(Arg_&& arg, Args_... args);
  std::string* mutable_properfilepath();
  PROTOBUF_NODISCARD std::string* release_properfilepath();
  void set_allocated_properfilepath(std::string* value);

  private:
  const std::string& _internal_properfilepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_properfilepath(
      const std::string& value);
  std::string* _internal_mutable_properfilepath();

  public:
  // bytes patternstring = 48;
  void clear_patternstring() ;
  const std::string& patternstring() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_patternstring(Arg_&& arg, Args_... args);
  std::string* mutable_patternstring();
  PROTOBUF_NODISCARD std::string* release_patternstring();
  void set_allocated_patternstring(std::string* value);

  private:
  const std::string& _internal_patternstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_patternstring(
      const std::string& value);
  std::string* _internal_mutable_patternstring();

  public:
  // bytes ErrorCodestring = 50;
  void clear_errorcodestring() ;
  const std::string& errorcodestring() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_errorcodestring(Arg_&& arg, Args_... args);
  std::string* mutable_errorcodestring();
  PROTOBUF_NODISCARD std::string* release_errorcodestring();
  void set_allocated_errorcodestring(std::string* value);

  private:
  const std::string& _internal_errorcodestring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errorcodestring(
      const std::string& value);
  std::string* _internal_mutable_errorcodestring();

  public:
  // bytes importArray = 51;
  void clear_importarray() ;
  const std::string& importarray() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_importarray(Arg_&& arg, Args_... args);
  std::string* mutable_importarray();
  PROTOBUF_NODISCARD std::string* release_importarray();
  void set_allocated_importarray(std::string* value);

  private:
  const std::string& _internal_importarray() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_importarray(
      const std::string& value);
  std::string* _internal_mutable_importarray();

  public:
  // bytes featureArray = 52;
  void clear_featurearray() ;
  const std::string& featurearray() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_featurearray(Arg_&& arg, Args_... args);
  std::string* mutable_featurearray();
  PROTOBUF_NODISCARD std::string* release_featurearray();
  void set_allocated_featurearray(std::string* value);

  private:
  const std::string& _internal_featurearray() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_featurearray(
      const std::string& value);
  std::string* _internal_mutable_featurearray();

  public:
  // .malwareClassifierAnalysis MCAnalysis = 44;
  bool has_mcanalysis() const;
  void clear_mcanalysis() ;
  const ::malwareClassifierAnalysis& mcanalysis() const;
  PROTOBUF_NODISCARD ::malwareClassifierAnalysis* release_mcanalysis();
  ::malwareClassifierAnalysis* mutable_mcanalysis();
  void set_allocated_mcanalysis(::malwareClassifierAnalysis* value);
  void unsafe_arena_set_allocated_mcanalysis(::malwareClassifierAnalysis* value);
  ::malwareClassifierAnalysis* unsafe_arena_release_mcanalysis();

  private:
  const ::malwareClassifierAnalysis& _internal_mcanalysis() const;
  ::malwareClassifierAnalysis* _internal_mutable_mcanalysis();

  public:
  // int32 fileSize = 29;
  void clear_filesize() ;
  ::int32_t filesize() const;
  void set_filesize(::int32_t value);

  private:
  ::int32_t _internal_filesize() const;
  void _internal_set_filesize(::int32_t value);

  public:
  // int32 Signtype = 30;
  void clear_signtype() ;
  ::int32_t signtype() const;
  void set_signtype(::int32_t value);

  private:
  ::int32_t _internal_signtype() const;
  void _internal_set_signtype(::int32_t value);

  public:
  // int32 NumberofCertChains = 31;
  void clear_numberofcertchains() ;
  ::int32_t numberofcertchains() const;
  void set_numberofcertchains(::int32_t value);

  private:
  ::int32_t _internal_numberofcertchains() const;
  void _internal_set_numberofcertchains(::int32_t value);

  public:
  // int32 Characteristics = 32;
  void clear_characteristics() ;
  ::int32_t characteristics() const;
  void set_characteristics(::int32_t value);

  private:
  ::int32_t _internal_characteristics() const;
  void _internal_set_characteristics(::int32_t value);

  public:
  // int32 Filetype = 33;
  void clear_filetype() ;
  ::int32_t filetype() const;
  void set_filetype(::int32_t value);

  private:
  ::int32_t _internal_filetype() const;
  void _internal_set_filetype(::int32_t value);

  public:
  // int32 Binarytime = 34;
  void clear_binarytime() ;
  ::int32_t binarytime() const;
  void set_binarytime(::int32_t value);

  private:
  ::int32_t _internal_binarytime() const;
  void _internal_set_binarytime(::int32_t value);

  public:
  // int32 BinaryType = 35;
  void clear_binarytype() ;
  ::int32_t binarytype() const;
  void set_binarytype(::int32_t value);

  private:
  ::int32_t _internal_binarytype() const;
  void _internal_set_binarytype(::int32_t value);

  public:
  // int32 MachineType = 36;
  void clear_machinetype() ;
  ::int32_t machinetype() const;
  void set_machinetype(::int32_t value);

  private:
  ::int32_t _internal_machinetype() const;
  void _internal_set_machinetype(::int32_t value);

  public:
  // int32 isMalware = 37;
  void clear_ismalware() ;
  ::int32_t ismalware() const;
  void set_ismalware(::int32_t value);

  private:
  ::int32_t _internal_ismalware() const;
  void _internal_set_ismalware(::int32_t value);

  public:
  // float confidence = 38;
  void clear_confidence() ;
  float confidence() const;
  void set_confidence(float value);

  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);

  public:
  // int32 impMalware = 39;
  void clear_impmalware() ;
  ::int32_t impmalware() const;
  void set_impmalware(::int32_t value);

  private:
  ::int32_t _internal_impmalware() const;
  void _internal_set_impmalware(::int32_t value);

  public:
  // int32 featureMalware = 40;
  void clear_featuremalware() ;
  ::int32_t featuremalware() const;
  void set_featuremalware(::int32_t value);

  private:
  ::int32_t _internal_featuremalware() const;
  void _internal_set_featuremalware(::int32_t value);

  public:
  // int32 ErrorCode = 43;
  void clear_errorcode() ;
  ::int32_t errorcode() const;
  void set_errorcode(::int32_t value);

  private:
  ::int32_t _internal_errorcode() const;
  void _internal_set_errorcode(::int32_t value);

  public:
  // int32 patternOffset = 49;
  void clear_patternoffset() ;
  ::int32_t patternoffset() const;
  void set_patternoffset(::int32_t value);

  private:
  ::int32_t _internal_patternoffset() const;
  void _internal_set_patternoffset(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ImgDetails)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 50, 1,
      0, 9>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr publisher_;
    ::google::protobuf::internal::ArenaStringPtr catafile_;
    ::google::protobuf::internal::ArenaStringPtr timestamp_;
    ::google::protobuf::internal::ArenaStringPtr vsignchainversion_;
    ::google::protobuf::internal::ArenaStringPtr digestalgorithm_;
    ::google::protobuf::internal::ArenaStringPtr imphase_hash_;
    ::google::protobuf::internal::ArenaStringPtr imphash_string_;
    ::google::protobuf::internal::ArenaStringPtr permission_;
    ::google::protobuf::internal::ArenaStringPtr company_;
    ::google::protobuf::internal::ArenaStringPtr description_;
    ::google::protobuf::internal::ArenaStringPtr product_;
    ::google::protobuf::internal::ArenaStringPtr internalname_;
    ::google::protobuf::internal::ArenaStringPtr copyrights_;
    ::google::protobuf::internal::ArenaStringPtr orgfilename_;
    ::google::protobuf::internal::ArenaStringPtr productversion_;
    ::google::protobuf::internal::ArenaStringPtr fileversion_;
    ::google::protobuf::internal::ArenaStringPtr mimetype_;
    ::google::protobuf::internal::ArenaStringPtr filetypeext_;
    ::google::protobuf::internal::ArenaStringPtr writetime_;
    ::google::protobuf::internal::ArenaStringPtr accesstime_;
    ::google::protobuf::internal::ArenaStringPtr createtime_;
    ::google::protobuf::internal::ArenaStringPtr md5le_buffer_;
    ::google::protobuf::internal::ArenaStringPtr sha1_buffer_;
    ::google::protobuf::internal::ArenaStringPtr sha256_buffer_;
    ::google::protobuf::internal::ArenaStringPtr sha512_buffer_;
    ::google::protobuf::internal::ArenaStringPtr status_;
    ::google::protobuf::internal::ArenaStringPtr thumbprint_;
    ::google::protobuf::internal::ArenaStringPtr sign_alg_;
    ::google::protobuf::internal::ArenaStringPtr filepath_;
    ::google::protobuf::internal::ArenaStringPtr importfunctionstring_;
    ::google::protobuf::internal::ArenaStringPtr properfilepath_;
    ::google::protobuf::internal::ArenaStringPtr patternstring_;
    ::google::protobuf::internal::ArenaStringPtr errorcodestring_;
    ::google::protobuf::internal::ArenaStringPtr importarray_;
    ::google::protobuf::internal::ArenaStringPtr featurearray_;
    ::malwareClassifierAnalysis* mcanalysis_;
    ::int32_t filesize_;
    ::int32_t signtype_;
    ::int32_t numberofcertchains_;
    ::int32_t characteristics_;
    ::int32_t filetype_;
    ::int32_t binarytime_;
    ::int32_t binarytype_;
    ::int32_t machinetype_;
    ::int32_t ismalware_;
    float confidence_;
    ::int32_t impmalware_;
    ::int32_t featuremalware_;
    ::int32_t errorcode_;
    ::int32_t patternoffset_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_imgDetails_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// malwareClassifierAnalysis

// int32 multifamilyResult = 1;
inline void malwareClassifierAnalysis::clear_multifamilyresult() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multifamilyresult_ = 0;
}
inline ::int32_t malwareClassifierAnalysis::multifamilyresult() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.multifamilyResult)
  return _internal_multifamilyresult();
}
inline void malwareClassifierAnalysis::set_multifamilyresult(::int32_t value) {
  _internal_set_multifamilyresult(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.multifamilyResult)
}
inline ::int32_t malwareClassifierAnalysis::_internal_multifamilyresult() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multifamilyresult_;
}
inline void malwareClassifierAnalysis::_internal_set_multifamilyresult(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multifamilyresult_ = value;
}

// float BenignProb = 2;
inline void malwareClassifierAnalysis::clear_benignprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.benignprob_ = 0;
}
inline float malwareClassifierAnalysis::benignprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.BenignProb)
  return _internal_benignprob();
}
inline void malwareClassifierAnalysis::set_benignprob(float value) {
  _internal_set_benignprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.BenignProb)
}
inline float malwareClassifierAnalysis::_internal_benignprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.benignprob_;
}
inline void malwareClassifierAnalysis::_internal_set_benignprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.benignprob_ = value;
}

// float DownloaderInstallerDropperProb = 3;
inline void malwareClassifierAnalysis::clear_downloaderinstallerdropperprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.downloaderinstallerdropperprob_ = 0;
}
inline float malwareClassifierAnalysis::downloaderinstallerdropperprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.DownloaderInstallerDropperProb)
  return _internal_downloaderinstallerdropperprob();
}
inline void malwareClassifierAnalysis::set_downloaderinstallerdropperprob(float value) {
  _internal_set_downloaderinstallerdropperprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.DownloaderInstallerDropperProb)
}
inline float malwareClassifierAnalysis::_internal_downloaderinstallerdropperprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.downloaderinstallerdropperprob_;
}
inline void malwareClassifierAnalysis::_internal_set_downloaderinstallerdropperprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.downloaderinstallerdropperprob_ = value;
}

// float FlooderInfectorVirusProb = 4;
inline void malwareClassifierAnalysis::clear_flooderinfectorvirusprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flooderinfectorvirusprob_ = 0;
}
inline float malwareClassifierAnalysis::flooderinfectorvirusprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.FlooderInfectorVirusProb)
  return _internal_flooderinfectorvirusprob();
}
inline void malwareClassifierAnalysis::set_flooderinfectorvirusprob(float value) {
  _internal_set_flooderinfectorvirusprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.FlooderInfectorVirusProb)
}
inline float malwareClassifierAnalysis::_internal_flooderinfectorvirusprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flooderinfectorvirusprob_;
}
inline void malwareClassifierAnalysis::_internal_set_flooderinfectorvirusprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flooderinfectorvirusprob_ = value;
}

// float RansomwareProb = 5;
inline void malwareClassifierAnalysis::clear_ransomwareprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ransomwareprob_ = 0;
}
inline float malwareClassifierAnalysis::ransomwareprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.RansomwareProb)
  return _internal_ransomwareprob();
}
inline void malwareClassifierAnalysis::set_ransomwareprob(float value) {
  _internal_set_ransomwareprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.RansomwareProb)
}
inline float malwareClassifierAnalysis::_internal_ransomwareprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ransomwareprob_;
}
inline void malwareClassifierAnalysis::_internal_set_ransomwareprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ransomwareprob_ = value;
}

// float SpywareStealerProb = 6;
inline void malwareClassifierAnalysis::clear_spywarestealerprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spywarestealerprob_ = 0;
}
inline float malwareClassifierAnalysis::spywarestealerprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.SpywareStealerProb)
  return _internal_spywarestealerprob();
}
inline void malwareClassifierAnalysis::set_spywarestealerprob(float value) {
  _internal_set_spywarestealerprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.SpywareStealerProb)
}
inline float malwareClassifierAnalysis::_internal_spywarestealerprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.spywarestealerprob_;
}
inline void malwareClassifierAnalysis::_internal_set_spywarestealerprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spywarestealerprob_ = value;
}

// float WormProb = 7;
inline void malwareClassifierAnalysis::clear_wormprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wormprob_ = 0;
}
inline float malwareClassifierAnalysis::wormprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.WormProb)
  return _internal_wormprob();
}
inline void malwareClassifierAnalysis::set_wormprob(float value) {
  _internal_set_wormprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.WormProb)
}
inline float malwareClassifierAnalysis::_internal_wormprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wormprob_;
}
inline void malwareClassifierAnalysis::_internal_set_wormprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wormprob_ = value;
}

// float BackdoorProb = 8;
inline void malwareClassifierAnalysis::clear_backdoorprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.backdoorprob_ = 0;
}
inline float malwareClassifierAnalysis::backdoorprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.BackdoorProb)
  return _internal_backdoorprob();
}
inline void malwareClassifierAnalysis::set_backdoorprob(float value) {
  _internal_set_backdoorprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.BackdoorProb)
}
inline float malwareClassifierAnalysis::_internal_backdoorprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.backdoorprob_;
}
inline void malwareClassifierAnalysis::_internal_set_backdoorprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.backdoorprob_ = value;
}

// float GenericProb = 9;
inline void malwareClassifierAnalysis::clear_genericprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.genericprob_ = 0;
}
inline float malwareClassifierAnalysis::genericprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.GenericProb)
  return _internal_genericprob();
}
inline void malwareClassifierAnalysis::set_genericprob(float value) {
  _internal_set_genericprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.GenericProb)
}
inline float malwareClassifierAnalysis::_internal_genericprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.genericprob_;
}
inline void malwareClassifierAnalysis::_internal_set_genericprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.genericprob_ = value;
}

// float ImportProb = 10;
inline void malwareClassifierAnalysis::clear_importprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importprob_ = 0;
}
inline float malwareClassifierAnalysis::importprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.ImportProb)
  return _internal_importprob();
}
inline void malwareClassifierAnalysis::set_importprob(float value) {
  _internal_set_importprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.ImportProb)
}
inline float malwareClassifierAnalysis::_internal_importprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.importprob_;
}
inline void malwareClassifierAnalysis::_internal_set_importprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importprob_ = value;
}

// float featureProb = 11;
inline void malwareClassifierAnalysis::clear_featureprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featureprob_ = 0;
}
inline float malwareClassifierAnalysis::featureprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.featureProb)
  return _internal_featureprob();
}
inline void malwareClassifierAnalysis::set_featureprob(float value) {
  _internal_set_featureprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.featureProb)
}
inline float malwareClassifierAnalysis::_internal_featureprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.featureprob_;
}
inline void malwareClassifierAnalysis::_internal_set_featureprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featureprob_ = value;
}

// float combineProb = 12;
inline void malwareClassifierAnalysis::clear_combineprob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.combineprob_ = 0;
}
inline float malwareClassifierAnalysis::combineprob() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.combineProb)
  return _internal_combineprob();
}
inline void malwareClassifierAnalysis::set_combineprob(float value) {
  _internal_set_combineprob(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.combineProb)
}
inline float malwareClassifierAnalysis::_internal_combineprob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.combineprob_;
}
inline void malwareClassifierAnalysis::_internal_set_combineprob(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.combineprob_ = value;
}

// int32 binaryModelResult = 13;
inline void malwareClassifierAnalysis::clear_binarymodelresult() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binarymodelresult_ = 0;
}
inline ::int32_t malwareClassifierAnalysis::binarymodelresult() const {
  // @@protoc_insertion_point(field_get:malwareClassifierAnalysis.binaryModelResult)
  return _internal_binarymodelresult();
}
inline void malwareClassifierAnalysis::set_binarymodelresult(::int32_t value) {
  _internal_set_binarymodelresult(value);
  // @@protoc_insertion_point(field_set:malwareClassifierAnalysis.binaryModelResult)
}
inline ::int32_t malwareClassifierAnalysis::_internal_binarymodelresult() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binarymodelresult_;
}
inline void malwareClassifierAnalysis::_internal_set_binarymodelresult(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binarymodelresult_ = value;
}

// -------------------------------------------------------------------

// ImgDetails

// bytes publisher = 1;
inline void ImgDetails::clear_publisher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisher_.ClearToEmpty();
}
inline const std::string& ImgDetails::publisher() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.publisher)
  return _internal_publisher();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_publisher(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisher_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.publisher)
}
inline std::string* ImgDetails::mutable_publisher() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:ImgDetails.publisher)
  return _s;
}
inline const std::string& ImgDetails::_internal_publisher() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.publisher_.Get();
}
inline void ImgDetails::_internal_set_publisher(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisher_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_publisher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.publisher_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_publisher() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.publisher)
  return _impl_.publisher_.Release();
}
inline void ImgDetails::set_allocated_publisher(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.publisher_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.publisher_.IsDefault()) {
          _impl_.publisher_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.publisher)
}

// bytes CataFile = 2;
inline void ImgDetails::clear_catafile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catafile_.ClearToEmpty();
}
inline const std::string& ImgDetails::catafile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.CataFile)
  return _internal_catafile();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_catafile(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catafile_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.CataFile)
}
inline std::string* ImgDetails::mutable_catafile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_catafile();
  // @@protoc_insertion_point(field_mutable:ImgDetails.CataFile)
  return _s;
}
inline const std::string& ImgDetails::_internal_catafile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.catafile_.Get();
}
inline void ImgDetails::_internal_set_catafile(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catafile_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_catafile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.catafile_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_catafile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.CataFile)
  return _impl_.catafile_.Release();
}
inline void ImgDetails::set_allocated_catafile(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.catafile_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.catafile_.IsDefault()) {
          _impl_.catafile_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.CataFile)
}

// bytes TimeStamp = 3;
inline void ImgDetails::clear_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_.ClearToEmpty();
}
inline const std::string& ImgDetails::timestamp() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.TimeStamp)
  return _internal_timestamp();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_timestamp(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.TimeStamp)
}
inline std::string* ImgDetails::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:ImgDetails.TimeStamp)
  return _s;
}
inline const std::string& ImgDetails::_internal_timestamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timestamp_.Get();
}
inline void ImgDetails::_internal_set_timestamp(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.timestamp_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_timestamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.TimeStamp)
  return _impl_.timestamp_.Release();
}
inline void ImgDetails::set_allocated_timestamp(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timestamp_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.timestamp_.IsDefault()) {
          _impl_.timestamp_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.TimeStamp)
}

// bytes VSignChainversion = 4;
inline void ImgDetails::clear_vsignchainversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vsignchainversion_.ClearToEmpty();
}
inline const std::string& ImgDetails::vsignchainversion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.VSignChainversion)
  return _internal_vsignchainversion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_vsignchainversion(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vsignchainversion_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.VSignChainversion)
}
inline std::string* ImgDetails::mutable_vsignchainversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_vsignchainversion();
  // @@protoc_insertion_point(field_mutable:ImgDetails.VSignChainversion)
  return _s;
}
inline const std::string& ImgDetails::_internal_vsignchainversion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vsignchainversion_.Get();
}
inline void ImgDetails::_internal_set_vsignchainversion(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vsignchainversion_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_vsignchainversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.vsignchainversion_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_vsignchainversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.VSignChainversion)
  return _impl_.vsignchainversion_.Release();
}
inline void ImgDetails::set_allocated_vsignchainversion(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vsignchainversion_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.vsignchainversion_.IsDefault()) {
          _impl_.vsignchainversion_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.VSignChainversion)
}

// bytes DigestAlgorithm = 5;
inline void ImgDetails::clear_digestalgorithm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digestalgorithm_.ClearToEmpty();
}
inline const std::string& ImgDetails::digestalgorithm() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.DigestAlgorithm)
  return _internal_digestalgorithm();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_digestalgorithm(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digestalgorithm_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.DigestAlgorithm)
}
inline std::string* ImgDetails::mutable_digestalgorithm() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_digestalgorithm();
  // @@protoc_insertion_point(field_mutable:ImgDetails.DigestAlgorithm)
  return _s;
}
inline const std::string& ImgDetails::_internal_digestalgorithm() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digestalgorithm_.Get();
}
inline void ImgDetails::_internal_set_digestalgorithm(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digestalgorithm_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_digestalgorithm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.digestalgorithm_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_digestalgorithm() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.DigestAlgorithm)
  return _impl_.digestalgorithm_.Release();
}
inline void ImgDetails::set_allocated_digestalgorithm(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.digestalgorithm_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.digestalgorithm_.IsDefault()) {
          _impl_.digestalgorithm_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.DigestAlgorithm)
}

// bytes Imphase_hash = 6;
inline void ImgDetails::clear_imphase_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphase_hash_.ClearToEmpty();
}
inline const std::string& ImgDetails::imphase_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Imphase_hash)
  return _internal_imphase_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_imphase_hash(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphase_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Imphase_hash)
}
inline std::string* ImgDetails::mutable_imphase_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_imphase_hash();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Imphase_hash)
  return _s;
}
inline const std::string& ImgDetails::_internal_imphase_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.imphase_hash_.Get();
}
inline void ImgDetails::_internal_set_imphase_hash(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphase_hash_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_imphase_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.imphase_hash_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_imphase_hash() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Imphase_hash)
  return _impl_.imphase_hash_.Release();
}
inline void ImgDetails::set_allocated_imphase_hash(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphase_hash_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.imphase_hash_.IsDefault()) {
          _impl_.imphase_hash_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Imphase_hash)
}

// bytes imphash_string = 7;
inline void ImgDetails::clear_imphash_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphash_string_.ClearToEmpty();
}
inline const std::string& ImgDetails::imphash_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.imphash_string)
  return _internal_imphash_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_imphash_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphash_string_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.imphash_string)
}
inline std::string* ImgDetails::mutable_imphash_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_imphash_string();
  // @@protoc_insertion_point(field_mutable:ImgDetails.imphash_string)
  return _s;
}
inline const std::string& ImgDetails::_internal_imphash_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.imphash_string_.Get();
}
inline void ImgDetails::_internal_set_imphash_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphash_string_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_imphash_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.imphash_string_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_imphash_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.imphash_string)
  return _impl_.imphash_string_.Release();
}
inline void ImgDetails::set_allocated_imphash_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.imphash_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.imphash_string_.IsDefault()) {
          _impl_.imphash_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.imphash_string)
}

// bytes Permission = 8;
inline void ImgDetails::clear_permission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permission_.ClearToEmpty();
}
inline const std::string& ImgDetails::permission() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Permission)
  return _internal_permission();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_permission(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permission_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Permission)
}
inline std::string* ImgDetails::mutable_permission() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_permission();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Permission)
  return _s;
}
inline const std::string& ImgDetails::_internal_permission() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.permission_.Get();
}
inline void ImgDetails::_internal_set_permission(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permission_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_permission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.permission_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_permission() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Permission)
  return _impl_.permission_.Release();
}
inline void ImgDetails::set_allocated_permission(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.permission_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.permission_.IsDefault()) {
          _impl_.permission_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Permission)
}

// bytes Company = 9;
inline void ImgDetails::clear_company() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.company_.ClearToEmpty();
}
inline const std::string& ImgDetails::company() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Company)
  return _internal_company();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_company(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.company_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Company)
}
inline std::string* ImgDetails::mutable_company() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_company();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Company)
  return _s;
}
inline const std::string& ImgDetails::_internal_company() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.company_.Get();
}
inline void ImgDetails::_internal_set_company(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.company_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_company() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.company_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_company() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Company)
  return _impl_.company_.Release();
}
inline void ImgDetails::set_allocated_company(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.company_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.company_.IsDefault()) {
          _impl_.company_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Company)
}

// bytes Description = 10;
inline void ImgDetails::clear_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ImgDetails::description() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Description)
  return _internal_description();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_description(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Description)
}
inline std::string* ImgDetails::mutable_description() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Description)
  return _s;
}
inline const std::string& ImgDetails::_internal_description() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.description_.Get();
}
inline void ImgDetails::_internal_set_description(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.description_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_description() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Description)
  return _impl_.description_.Release();
}
inline void ImgDetails::set_allocated_description(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.description_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.description_.IsDefault()) {
          _impl_.description_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Description)
}

// bytes Product = 11;
inline void ImgDetails::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_.ClearToEmpty();
}
inline const std::string& ImgDetails::product() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Product)
  return _internal_product();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_product(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Product)
}
inline std::string* ImgDetails::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Product)
  return _s;
}
inline const std::string& ImgDetails::_internal_product() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.product_.Get();
}
inline void ImgDetails::_internal_set_product(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.product_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Product)
  return _impl_.product_.Release();
}
inline void ImgDetails::set_allocated_product(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.product_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.product_.IsDefault()) {
          _impl_.product_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Product)
}

// bytes InternalName = 12;
inline void ImgDetails::clear_internalname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.internalname_.ClearToEmpty();
}
inline const std::string& ImgDetails::internalname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.InternalName)
  return _internal_internalname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_internalname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.internalname_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.InternalName)
}
inline std::string* ImgDetails::mutable_internalname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_internalname();
  // @@protoc_insertion_point(field_mutable:ImgDetails.InternalName)
  return _s;
}
inline const std::string& ImgDetails::_internal_internalname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.internalname_.Get();
}
inline void ImgDetails::_internal_set_internalname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.internalname_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_internalname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.internalname_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_internalname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.InternalName)
  return _impl_.internalname_.Release();
}
inline void ImgDetails::set_allocated_internalname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.internalname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.internalname_.IsDefault()) {
          _impl_.internalname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.InternalName)
}

// bytes CopyRights = 13;
inline void ImgDetails::clear_copyrights() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.copyrights_.ClearToEmpty();
}
inline const std::string& ImgDetails::copyrights() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.CopyRights)
  return _internal_copyrights();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_copyrights(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.copyrights_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.CopyRights)
}
inline std::string* ImgDetails::mutable_copyrights() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_copyrights();
  // @@protoc_insertion_point(field_mutable:ImgDetails.CopyRights)
  return _s;
}
inline const std::string& ImgDetails::_internal_copyrights() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.copyrights_.Get();
}
inline void ImgDetails::_internal_set_copyrights(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.copyrights_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_copyrights() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.copyrights_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_copyrights() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.CopyRights)
  return _impl_.copyrights_.Release();
}
inline void ImgDetails::set_allocated_copyrights(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.copyrights_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.copyrights_.IsDefault()) {
          _impl_.copyrights_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.CopyRights)
}

// bytes Orgfilename = 14;
inline void ImgDetails::clear_orgfilename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orgfilename_.ClearToEmpty();
}
inline const std::string& ImgDetails::orgfilename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Orgfilename)
  return _internal_orgfilename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_orgfilename(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orgfilename_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Orgfilename)
}
inline std::string* ImgDetails::mutable_orgfilename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_orgfilename();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Orgfilename)
  return _s;
}
inline const std::string& ImgDetails::_internal_orgfilename() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.orgfilename_.Get();
}
inline void ImgDetails::_internal_set_orgfilename(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orgfilename_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_orgfilename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.orgfilename_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_orgfilename() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Orgfilename)
  return _impl_.orgfilename_.Release();
}
inline void ImgDetails::set_allocated_orgfilename(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.orgfilename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.orgfilename_.IsDefault()) {
          _impl_.orgfilename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Orgfilename)
}

// bytes ProductVersion = 15;
inline void ImgDetails::clear_productversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.productversion_.ClearToEmpty();
}
inline const std::string& ImgDetails::productversion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.ProductVersion)
  return _internal_productversion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_productversion(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.productversion_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.ProductVersion)
}
inline std::string* ImgDetails::mutable_productversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_productversion();
  // @@protoc_insertion_point(field_mutable:ImgDetails.ProductVersion)
  return _s;
}
inline const std::string& ImgDetails::_internal_productversion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.productversion_.Get();
}
inline void ImgDetails::_internal_set_productversion(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.productversion_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_productversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.productversion_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_productversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.ProductVersion)
  return _impl_.productversion_.Release();
}
inline void ImgDetails::set_allocated_productversion(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.productversion_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.productversion_.IsDefault()) {
          _impl_.productversion_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.ProductVersion)
}

// bytes FileVersion = 16;
inline void ImgDetails::clear_fileversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fileversion_.ClearToEmpty();
}
inline const std::string& ImgDetails::fileversion() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.FileVersion)
  return _internal_fileversion();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_fileversion(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fileversion_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.FileVersion)
}
inline std::string* ImgDetails::mutable_fileversion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_fileversion();
  // @@protoc_insertion_point(field_mutable:ImgDetails.FileVersion)
  return _s;
}
inline const std::string& ImgDetails::_internal_fileversion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fileversion_.Get();
}
inline void ImgDetails::_internal_set_fileversion(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fileversion_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_fileversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.fileversion_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_fileversion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.FileVersion)
  return _impl_.fileversion_.Release();
}
inline void ImgDetails::set_allocated_fileversion(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fileversion_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.fileversion_.IsDefault()) {
          _impl_.fileversion_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.FileVersion)
}

// bytes Mimetype = 17;
inline void ImgDetails::clear_mimetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mimetype_.ClearToEmpty();
}
inline const std::string& ImgDetails::mimetype() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Mimetype)
  return _internal_mimetype();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_mimetype(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mimetype_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Mimetype)
}
inline std::string* ImgDetails::mutable_mimetype() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mimetype();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Mimetype)
  return _s;
}
inline const std::string& ImgDetails::_internal_mimetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mimetype_.Get();
}
inline void ImgDetails::_internal_set_mimetype(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mimetype_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_mimetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.mimetype_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_mimetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Mimetype)
  return _impl_.mimetype_.Release();
}
inline void ImgDetails::set_allocated_mimetype(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mimetype_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mimetype_.IsDefault()) {
          _impl_.mimetype_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Mimetype)
}

// bytes filetypeext = 18;
inline void ImgDetails::clear_filetypeext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetypeext_.ClearToEmpty();
}
inline const std::string& ImgDetails::filetypeext() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.filetypeext)
  return _internal_filetypeext();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_filetypeext(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetypeext_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.filetypeext)
}
inline std::string* ImgDetails::mutable_filetypeext() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filetypeext();
  // @@protoc_insertion_point(field_mutable:ImgDetails.filetypeext)
  return _s;
}
inline const std::string& ImgDetails::_internal_filetypeext() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filetypeext_.Get();
}
inline void ImgDetails::_internal_set_filetypeext(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetypeext_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_filetypeext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.filetypeext_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_filetypeext() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.filetypeext)
  return _impl_.filetypeext_.Release();
}
inline void ImgDetails::set_allocated_filetypeext(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetypeext_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filetypeext_.IsDefault()) {
          _impl_.filetypeext_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.filetypeext)
}

// bytes Writetime = 19;
inline void ImgDetails::clear_writetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.writetime_.ClearToEmpty();
}
inline const std::string& ImgDetails::writetime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Writetime)
  return _internal_writetime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_writetime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.writetime_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Writetime)
}
inline std::string* ImgDetails::mutable_writetime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_writetime();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Writetime)
  return _s;
}
inline const std::string& ImgDetails::_internal_writetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.writetime_.Get();
}
inline void ImgDetails::_internal_set_writetime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.writetime_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_writetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.writetime_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_writetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Writetime)
  return _impl_.writetime_.Release();
}
inline void ImgDetails::set_allocated_writetime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.writetime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.writetime_.IsDefault()) {
          _impl_.writetime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Writetime)
}

// bytes Accesstime = 20;
inline void ImgDetails::clear_accesstime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accesstime_.ClearToEmpty();
}
inline const std::string& ImgDetails::accesstime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Accesstime)
  return _internal_accesstime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_accesstime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accesstime_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Accesstime)
}
inline std::string* ImgDetails::mutable_accesstime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_accesstime();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Accesstime)
  return _s;
}
inline const std::string& ImgDetails::_internal_accesstime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.accesstime_.Get();
}
inline void ImgDetails::_internal_set_accesstime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accesstime_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_accesstime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.accesstime_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_accesstime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Accesstime)
  return _impl_.accesstime_.Release();
}
inline void ImgDetails::set_allocated_accesstime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.accesstime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.accesstime_.IsDefault()) {
          _impl_.accesstime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Accesstime)
}

// bytes Createtime = 21;
inline void ImgDetails::clear_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.ClearToEmpty();
}
inline const std::string& ImgDetails::createtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.Createtime)
  return _internal_createtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_createtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.Createtime)
}
inline std::string* ImgDetails::mutable_createtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:ImgDetails.Createtime)
  return _s;
}
inline const std::string& ImgDetails::_internal_createtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.createtime_.Get();
}
inline void ImgDetails::_internal_set_createtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.createtime_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.Createtime)
  return _impl_.createtime_.Release();
}
inline void ImgDetails::set_allocated_createtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.createtime_.IsDefault()) {
          _impl_.createtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.Createtime)
}

// bytes MD5LE_buffer = 22;
inline void ImgDetails::clear_md5le_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5le_buffer_.ClearToEmpty();
}
inline const std::string& ImgDetails::md5le_buffer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.MD5LE_buffer)
  return _internal_md5le_buffer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_md5le_buffer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5le_buffer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.MD5LE_buffer)
}
inline std::string* ImgDetails::mutable_md5le_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_md5le_buffer();
  // @@protoc_insertion_point(field_mutable:ImgDetails.MD5LE_buffer)
  return _s;
}
inline const std::string& ImgDetails::_internal_md5le_buffer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.md5le_buffer_.Get();
}
inline void ImgDetails::_internal_set_md5le_buffer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5le_buffer_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_md5le_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.md5le_buffer_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_md5le_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.MD5LE_buffer)
  return _impl_.md5le_buffer_.Release();
}
inline void ImgDetails::set_allocated_md5le_buffer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.md5le_buffer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.md5le_buffer_.IsDefault()) {
          _impl_.md5le_buffer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.MD5LE_buffer)
}

// bytes SHA1_buffer = 23;
inline void ImgDetails::clear_sha1_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha1_buffer_.ClearToEmpty();
}
inline const std::string& ImgDetails::sha1_buffer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.SHA1_buffer)
  return _internal_sha1_buffer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_sha1_buffer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha1_buffer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.SHA1_buffer)
}
inline std::string* ImgDetails::mutable_sha1_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sha1_buffer();
  // @@protoc_insertion_point(field_mutable:ImgDetails.SHA1_buffer)
  return _s;
}
inline const std::string& ImgDetails::_internal_sha1_buffer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sha1_buffer_.Get();
}
inline void ImgDetails::_internal_set_sha1_buffer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha1_buffer_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_sha1_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.sha1_buffer_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_sha1_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.SHA1_buffer)
  return _impl_.sha1_buffer_.Release();
}
inline void ImgDetails::set_allocated_sha1_buffer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha1_buffer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sha1_buffer_.IsDefault()) {
          _impl_.sha1_buffer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.SHA1_buffer)
}

// bytes SHA256_buffer = 24;
inline void ImgDetails::clear_sha256_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha256_buffer_.ClearToEmpty();
}
inline const std::string& ImgDetails::sha256_buffer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.SHA256_buffer)
  return _internal_sha256_buffer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_sha256_buffer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha256_buffer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.SHA256_buffer)
}
inline std::string* ImgDetails::mutable_sha256_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sha256_buffer();
  // @@protoc_insertion_point(field_mutable:ImgDetails.SHA256_buffer)
  return _s;
}
inline const std::string& ImgDetails::_internal_sha256_buffer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sha256_buffer_.Get();
}
inline void ImgDetails::_internal_set_sha256_buffer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha256_buffer_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_sha256_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.sha256_buffer_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_sha256_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.SHA256_buffer)
  return _impl_.sha256_buffer_.Release();
}
inline void ImgDetails::set_allocated_sha256_buffer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha256_buffer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sha256_buffer_.IsDefault()) {
          _impl_.sha256_buffer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.SHA256_buffer)
}

// bytes SHA512_buffer = 25;
inline void ImgDetails::clear_sha512_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha512_buffer_.ClearToEmpty();
}
inline const std::string& ImgDetails::sha512_buffer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.SHA512_buffer)
  return _internal_sha512_buffer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_sha512_buffer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha512_buffer_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.SHA512_buffer)
}
inline std::string* ImgDetails::mutable_sha512_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sha512_buffer();
  // @@protoc_insertion_point(field_mutable:ImgDetails.SHA512_buffer)
  return _s;
}
inline const std::string& ImgDetails::_internal_sha512_buffer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sha512_buffer_.Get();
}
inline void ImgDetails::_internal_set_sha512_buffer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha512_buffer_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_sha512_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.sha512_buffer_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_sha512_buffer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.SHA512_buffer)
  return _impl_.sha512_buffer_.Release();
}
inline void ImgDetails::set_allocated_sha512_buffer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sha512_buffer_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sha512_buffer_.IsDefault()) {
          _impl_.sha512_buffer_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.SHA512_buffer)
}

// bytes status = 26;
inline void ImgDetails::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.ClearToEmpty();
}
inline const std::string& ImgDetails::status() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.status)
  return _internal_status();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_status(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.status)
}
inline std::string* ImgDetails::mutable_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:ImgDetails.status)
  return _s;
}
inline const std::string& ImgDetails::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_.Get();
}
inline void ImgDetails::_internal_set_status(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.status_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.status)
  return _impl_.status_.Release();
}
inline void ImgDetails::set_allocated_status(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.status_.IsDefault()) {
          _impl_.status_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.status)
}

// bytes thumbprint = 27;
inline void ImgDetails::clear_thumbprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbprint_.ClearToEmpty();
}
inline const std::string& ImgDetails::thumbprint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.thumbprint)
  return _internal_thumbprint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_thumbprint(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbprint_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.thumbprint)
}
inline std::string* ImgDetails::mutable_thumbprint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_thumbprint();
  // @@protoc_insertion_point(field_mutable:ImgDetails.thumbprint)
  return _s;
}
inline const std::string& ImgDetails::_internal_thumbprint() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.thumbprint_.Get();
}
inline void ImgDetails::_internal_set_thumbprint(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbprint_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_thumbprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.thumbprint_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_thumbprint() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.thumbprint)
  return _impl_.thumbprint_.Release();
}
inline void ImgDetails::set_allocated_thumbprint(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.thumbprint_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.thumbprint_.IsDefault()) {
          _impl_.thumbprint_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.thumbprint)
}

// bytes sign_alg = 28;
inline void ImgDetails::clear_sign_alg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sign_alg_.ClearToEmpty();
}
inline const std::string& ImgDetails::sign_alg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.sign_alg)
  return _internal_sign_alg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_sign_alg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sign_alg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.sign_alg)
}
inline std::string* ImgDetails::mutable_sign_alg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sign_alg();
  // @@protoc_insertion_point(field_mutable:ImgDetails.sign_alg)
  return _s;
}
inline const std::string& ImgDetails::_internal_sign_alg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sign_alg_.Get();
}
inline void ImgDetails::_internal_set_sign_alg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sign_alg_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_sign_alg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.sign_alg_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_sign_alg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.sign_alg)
  return _impl_.sign_alg_.Release();
}
inline void ImgDetails::set_allocated_sign_alg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sign_alg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sign_alg_.IsDefault()) {
          _impl_.sign_alg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.sign_alg)
}

// int32 fileSize = 29;
inline void ImgDetails::clear_filesize() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filesize_ = 0;
}
inline ::int32_t ImgDetails::filesize() const {
  // @@protoc_insertion_point(field_get:ImgDetails.fileSize)
  return _internal_filesize();
}
inline void ImgDetails::set_filesize(::int32_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:ImgDetails.fileSize)
}
inline ::int32_t ImgDetails::_internal_filesize() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filesize_;
}
inline void ImgDetails::_internal_set_filesize(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filesize_ = value;
}

// int32 Signtype = 30;
inline void ImgDetails::clear_signtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signtype_ = 0;
}
inline ::int32_t ImgDetails::signtype() const {
  // @@protoc_insertion_point(field_get:ImgDetails.Signtype)
  return _internal_signtype();
}
inline void ImgDetails::set_signtype(::int32_t value) {
  _internal_set_signtype(value);
  // @@protoc_insertion_point(field_set:ImgDetails.Signtype)
}
inline ::int32_t ImgDetails::_internal_signtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.signtype_;
}
inline void ImgDetails::_internal_set_signtype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.signtype_ = value;
}

// int32 NumberofCertChains = 31;
inline void ImgDetails::clear_numberofcertchains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numberofcertchains_ = 0;
}
inline ::int32_t ImgDetails::numberofcertchains() const {
  // @@protoc_insertion_point(field_get:ImgDetails.NumberofCertChains)
  return _internal_numberofcertchains();
}
inline void ImgDetails::set_numberofcertchains(::int32_t value) {
  _internal_set_numberofcertchains(value);
  // @@protoc_insertion_point(field_set:ImgDetails.NumberofCertChains)
}
inline ::int32_t ImgDetails::_internal_numberofcertchains() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.numberofcertchains_;
}
inline void ImgDetails::_internal_set_numberofcertchains(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.numberofcertchains_ = value;
}

// int32 Characteristics = 32;
inline void ImgDetails::clear_characteristics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.characteristics_ = 0;
}
inline ::int32_t ImgDetails::characteristics() const {
  // @@protoc_insertion_point(field_get:ImgDetails.Characteristics)
  return _internal_characteristics();
}
inline void ImgDetails::set_characteristics(::int32_t value) {
  _internal_set_characteristics(value);
  // @@protoc_insertion_point(field_set:ImgDetails.Characteristics)
}
inline ::int32_t ImgDetails::_internal_characteristics() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.characteristics_;
}
inline void ImgDetails::_internal_set_characteristics(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.characteristics_ = value;
}

// int32 Filetype = 33;
inline void ImgDetails::clear_filetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetype_ = 0;
}
inline ::int32_t ImgDetails::filetype() const {
  // @@protoc_insertion_point(field_get:ImgDetails.Filetype)
  return _internal_filetype();
}
inline void ImgDetails::set_filetype(::int32_t value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:ImgDetails.Filetype)
}
inline ::int32_t ImgDetails::_internal_filetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filetype_;
}
inline void ImgDetails::_internal_set_filetype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filetype_ = value;
}

// int32 Binarytime = 34;
inline void ImgDetails::clear_binarytime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binarytime_ = 0;
}
inline ::int32_t ImgDetails::binarytime() const {
  // @@protoc_insertion_point(field_get:ImgDetails.Binarytime)
  return _internal_binarytime();
}
inline void ImgDetails::set_binarytime(::int32_t value) {
  _internal_set_binarytime(value);
  // @@protoc_insertion_point(field_set:ImgDetails.Binarytime)
}
inline ::int32_t ImgDetails::_internal_binarytime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binarytime_;
}
inline void ImgDetails::_internal_set_binarytime(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binarytime_ = value;
}

// int32 BinaryType = 35;
inline void ImgDetails::clear_binarytype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binarytype_ = 0;
}
inline ::int32_t ImgDetails::binarytype() const {
  // @@protoc_insertion_point(field_get:ImgDetails.BinaryType)
  return _internal_binarytype();
}
inline void ImgDetails::set_binarytype(::int32_t value) {
  _internal_set_binarytype(value);
  // @@protoc_insertion_point(field_set:ImgDetails.BinaryType)
}
inline ::int32_t ImgDetails::_internal_binarytype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.binarytype_;
}
inline void ImgDetails::_internal_set_binarytype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.binarytype_ = value;
}

// int32 MachineType = 36;
inline void ImgDetails::clear_machinetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.machinetype_ = 0;
}
inline ::int32_t ImgDetails::machinetype() const {
  // @@protoc_insertion_point(field_get:ImgDetails.MachineType)
  return _internal_machinetype();
}
inline void ImgDetails::set_machinetype(::int32_t value) {
  _internal_set_machinetype(value);
  // @@protoc_insertion_point(field_set:ImgDetails.MachineType)
}
inline ::int32_t ImgDetails::_internal_machinetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.machinetype_;
}
inline void ImgDetails::_internal_set_machinetype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.machinetype_ = value;
}

// int32 isMalware = 37;
inline void ImgDetails::clear_ismalware() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ismalware_ = 0;
}
inline ::int32_t ImgDetails::ismalware() const {
  // @@protoc_insertion_point(field_get:ImgDetails.isMalware)
  return _internal_ismalware();
}
inline void ImgDetails::set_ismalware(::int32_t value) {
  _internal_set_ismalware(value);
  // @@protoc_insertion_point(field_set:ImgDetails.isMalware)
}
inline ::int32_t ImgDetails::_internal_ismalware() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ismalware_;
}
inline void ImgDetails::_internal_set_ismalware(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ismalware_ = value;
}

// float confidence = 38;
inline void ImgDetails::clear_confidence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.confidence_ = 0;
}
inline float ImgDetails::confidence() const {
  // @@protoc_insertion_point(field_get:ImgDetails.confidence)
  return _internal_confidence();
}
inline void ImgDetails::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:ImgDetails.confidence)
}
inline float ImgDetails::_internal_confidence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.confidence_;
}
inline void ImgDetails::_internal_set_confidence(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.confidence_ = value;
}

// int32 impMalware = 39;
inline void ImgDetails::clear_impmalware() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.impmalware_ = 0;
}
inline ::int32_t ImgDetails::impmalware() const {
  // @@protoc_insertion_point(field_get:ImgDetails.impMalware)
  return _internal_impmalware();
}
inline void ImgDetails::set_impmalware(::int32_t value) {
  _internal_set_impmalware(value);
  // @@protoc_insertion_point(field_set:ImgDetails.impMalware)
}
inline ::int32_t ImgDetails::_internal_impmalware() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.impmalware_;
}
inline void ImgDetails::_internal_set_impmalware(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.impmalware_ = value;
}

// int32 featureMalware = 40;
inline void ImgDetails::clear_featuremalware() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featuremalware_ = 0;
}
inline ::int32_t ImgDetails::featuremalware() const {
  // @@protoc_insertion_point(field_get:ImgDetails.featureMalware)
  return _internal_featuremalware();
}
inline void ImgDetails::set_featuremalware(::int32_t value) {
  _internal_set_featuremalware(value);
  // @@protoc_insertion_point(field_set:ImgDetails.featureMalware)
}
inline ::int32_t ImgDetails::_internal_featuremalware() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.featuremalware_;
}
inline void ImgDetails::_internal_set_featuremalware(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featuremalware_ = value;
}

// bytes filePath = 42;
inline void ImgDetails::clear_filepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& ImgDetails::filepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.filePath)
  return _internal_filepath();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_filepath(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.filePath)
}
inline std::string* ImgDetails::mutable_filepath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:ImgDetails.filePath)
  return _s;
}
inline const std::string& ImgDetails::_internal_filepath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filepath_.Get();
}
inline void ImgDetails::_internal_set_filepath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_filepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.filepath_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_filepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.filePath)
  return _impl_.filepath_.Release();
}
inline void ImgDetails::set_allocated_filepath(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filepath_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filepath_.IsDefault()) {
          _impl_.filepath_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.filePath)
}

// int32 ErrorCode = 43;
inline void ImgDetails::clear_errorcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcode_ = 0;
}
inline ::int32_t ImgDetails::errorcode() const {
  // @@protoc_insertion_point(field_get:ImgDetails.ErrorCode)
  return _internal_errorcode();
}
inline void ImgDetails::set_errorcode(::int32_t value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:ImgDetails.ErrorCode)
}
inline ::int32_t ImgDetails::_internal_errorcode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errorcode_;
}
inline void ImgDetails::_internal_set_errorcode(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcode_ = value;
}

// .malwareClassifierAnalysis MCAnalysis = 44;
inline bool ImgDetails::has_mcanalysis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mcanalysis_ != nullptr);
  return value;
}
inline void ImgDetails::clear_mcanalysis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mcanalysis_ != nullptr) _impl_.mcanalysis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::malwareClassifierAnalysis& ImgDetails::_internal_mcanalysis() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::malwareClassifierAnalysis* p = _impl_.mcanalysis_;
  return p != nullptr ? *p : reinterpret_cast<const ::malwareClassifierAnalysis&>(::_malwareClassifierAnalysis_default_instance_);
}
inline const ::malwareClassifierAnalysis& ImgDetails::mcanalysis() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.MCAnalysis)
  return _internal_mcanalysis();
}
inline void ImgDetails::unsafe_arena_set_allocated_mcanalysis(::malwareClassifierAnalysis* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.mcanalysis_);
  }
  _impl_.mcanalysis_ = reinterpret_cast<::malwareClassifierAnalysis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ImgDetails.MCAnalysis)
}
inline ::malwareClassifierAnalysis* ImgDetails::release_mcanalysis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::malwareClassifierAnalysis* released = _impl_.mcanalysis_;
  _impl_.mcanalysis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::malwareClassifierAnalysis* ImgDetails::unsafe_arena_release_mcanalysis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.MCAnalysis)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::malwareClassifierAnalysis* temp = _impl_.mcanalysis_;
  _impl_.mcanalysis_ = nullptr;
  return temp;
}
inline ::malwareClassifierAnalysis* ImgDetails::_internal_mutable_mcanalysis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.mcanalysis_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::malwareClassifierAnalysis>(GetArena());
    _impl_.mcanalysis_ = reinterpret_cast<::malwareClassifierAnalysis*>(p);
  }
  return _impl_.mcanalysis_;
}
inline ::malwareClassifierAnalysis* ImgDetails::mutable_mcanalysis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::malwareClassifierAnalysis* _msg = _internal_mutable_mcanalysis();
  // @@protoc_insertion_point(field_mutable:ImgDetails.MCAnalysis)
  return _msg;
}
inline void ImgDetails::set_allocated_mcanalysis(::malwareClassifierAnalysis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.mcanalysis_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.mcanalysis_ = reinterpret_cast<::malwareClassifierAnalysis*>(value);
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.MCAnalysis)
}

// bytes importFunctionstring = 45;
inline void ImgDetails::clear_importfunctionstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importfunctionstring_.ClearToEmpty();
}
inline const std::string& ImgDetails::importfunctionstring() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.importFunctionstring)
  return _internal_importfunctionstring();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_importfunctionstring(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importfunctionstring_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.importFunctionstring)
}
inline std::string* ImgDetails::mutable_importfunctionstring() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_importfunctionstring();
  // @@protoc_insertion_point(field_mutable:ImgDetails.importFunctionstring)
  return _s;
}
inline const std::string& ImgDetails::_internal_importfunctionstring() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.importfunctionstring_.Get();
}
inline void ImgDetails::_internal_set_importfunctionstring(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importfunctionstring_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_importfunctionstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.importfunctionstring_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_importfunctionstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.importFunctionstring)
  return _impl_.importfunctionstring_.Release();
}
inline void ImgDetails::set_allocated_importfunctionstring(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importfunctionstring_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.importfunctionstring_.IsDefault()) {
          _impl_.importfunctionstring_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.importFunctionstring)
}

// bytes properFilePath = 47;
inline void ImgDetails::clear_properfilepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properfilepath_.ClearToEmpty();
}
inline const std::string& ImgDetails::properfilepath() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.properFilePath)
  return _internal_properfilepath();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_properfilepath(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properfilepath_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.properFilePath)
}
inline std::string* ImgDetails::mutable_properfilepath() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_properfilepath();
  // @@protoc_insertion_point(field_mutable:ImgDetails.properFilePath)
  return _s;
}
inline const std::string& ImgDetails::_internal_properfilepath() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.properfilepath_.Get();
}
inline void ImgDetails::_internal_set_properfilepath(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properfilepath_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_properfilepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.properfilepath_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_properfilepath() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.properFilePath)
  return _impl_.properfilepath_.Release();
}
inline void ImgDetails::set_allocated_properfilepath(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.properfilepath_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.properfilepath_.IsDefault()) {
          _impl_.properfilepath_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.properFilePath)
}

// bytes patternstring = 48;
inline void ImgDetails::clear_patternstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patternstring_.ClearToEmpty();
}
inline const std::string& ImgDetails::patternstring() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.patternstring)
  return _internal_patternstring();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_patternstring(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patternstring_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.patternstring)
}
inline std::string* ImgDetails::mutable_patternstring() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_patternstring();
  // @@protoc_insertion_point(field_mutable:ImgDetails.patternstring)
  return _s;
}
inline const std::string& ImgDetails::_internal_patternstring() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.patternstring_.Get();
}
inline void ImgDetails::_internal_set_patternstring(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patternstring_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_patternstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.patternstring_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_patternstring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.patternstring)
  return _impl_.patternstring_.Release();
}
inline void ImgDetails::set_allocated_patternstring(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patternstring_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.patternstring_.IsDefault()) {
          _impl_.patternstring_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.patternstring)
}

// int32 patternOffset = 49;
inline void ImgDetails::clear_patternoffset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patternoffset_ = 0;
}
inline ::int32_t ImgDetails::patternoffset() const {
  // @@protoc_insertion_point(field_get:ImgDetails.patternOffset)
  return _internal_patternoffset();
}
inline void ImgDetails::set_patternoffset(::int32_t value) {
  _internal_set_patternoffset(value);
  // @@protoc_insertion_point(field_set:ImgDetails.patternOffset)
}
inline ::int32_t ImgDetails::_internal_patternoffset() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.patternoffset_;
}
inline void ImgDetails::_internal_set_patternoffset(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.patternoffset_ = value;
}

// bytes ErrorCodestring = 50;
inline void ImgDetails::clear_errorcodestring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcodestring_.ClearToEmpty();
}
inline const std::string& ImgDetails::errorcodestring() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.ErrorCodestring)
  return _internal_errorcodestring();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_errorcodestring(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcodestring_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.ErrorCodestring)
}
inline std::string* ImgDetails::mutable_errorcodestring() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_errorcodestring();
  // @@protoc_insertion_point(field_mutable:ImgDetails.ErrorCodestring)
  return _s;
}
inline const std::string& ImgDetails::_internal_errorcodestring() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errorcodestring_.Get();
}
inline void ImgDetails::_internal_set_errorcodestring(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcodestring_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_errorcodestring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.errorcodestring_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_errorcodestring() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.ErrorCodestring)
  return _impl_.errorcodestring_.Release();
}
inline void ImgDetails::set_allocated_errorcodestring(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcodestring_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.errorcodestring_.IsDefault()) {
          _impl_.errorcodestring_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.ErrorCodestring)
}

// bytes importArray = 51;
inline void ImgDetails::clear_importarray() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importarray_.ClearToEmpty();
}
inline const std::string& ImgDetails::importarray() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.importArray)
  return _internal_importarray();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_importarray(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importarray_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.importArray)
}
inline std::string* ImgDetails::mutable_importarray() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_importarray();
  // @@protoc_insertion_point(field_mutable:ImgDetails.importArray)
  return _s;
}
inline const std::string& ImgDetails::_internal_importarray() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.importarray_.Get();
}
inline void ImgDetails::_internal_set_importarray(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importarray_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_importarray() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.importarray_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_importarray() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.importArray)
  return _impl_.importarray_.Release();
}
inline void ImgDetails::set_allocated_importarray(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.importarray_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.importarray_.IsDefault()) {
          _impl_.importarray_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.importArray)
}

// bytes featureArray = 52;
inline void ImgDetails::clear_featurearray() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featurearray_.ClearToEmpty();
}
inline const std::string& ImgDetails::featurearray() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ImgDetails.featureArray)
  return _internal_featurearray();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ImgDetails::set_featurearray(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featurearray_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ImgDetails.featureArray)
}
inline std::string* ImgDetails::mutable_featurearray() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_featurearray();
  // @@protoc_insertion_point(field_mutable:ImgDetails.featureArray)
  return _s;
}
inline const std::string& ImgDetails::_internal_featurearray() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.featurearray_.Get();
}
inline void ImgDetails::_internal_set_featurearray(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featurearray_.Set(value, GetArena());
}
inline std::string* ImgDetails::_internal_mutable_featurearray() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.featurearray_.Mutable( GetArena());
}
inline std::string* ImgDetails::release_featurearray() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ImgDetails.featureArray)
  return _impl_.featurearray_.Release();
}
inline void ImgDetails::set_allocated_featurearray(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.featurearray_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.featurearray_.IsDefault()) {
          _impl_.featurearray_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ImgDetails.featureArray)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_imgDetails_2eproto_2epb_2eh
