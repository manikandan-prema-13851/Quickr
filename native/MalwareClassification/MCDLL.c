#include "MCHeader.h"
#include <windows.h>
#include <string.h>

const char* publisherName1 = "microsoft windows";
const char* publisherName2 = "microsoft corporation";
int arrayCombinedZerothIndex = 0;
int arrayCombinedFirstIndex = 1;


void mcAnalysisDetailsSetter(struct PEImgDetails* data,float featureProb, float ImportProb, float combineProb, int64_t binaryModelResult){
	data->mcAnalysis.featureprob = featureProb;
	data->mcAnalysis.importprob = ImportProb;
	data->mcAnalysis.combineprob = combineProb;
	data->mcAnalysis.isMcMalware = binaryModelResult;
}

int __declspec(dllexport) initMCModel(wchar_t* modelFile, wchar_t* importModelFile, wchar_t* nbModelFile) {
	return EXIT_FAILURE;
}

int __declspec(dllexport) freeMCModel() {
	return EXIT_FAILURE;
}

double logitToProbability(double logit) {
	return 1.0 / (1.0 + exp(-logit));
}

void featureModelWrapper(const float tensor_X[1][2224], int64_t tensor_label[1], float tensor_probabilities[1][1]) {
	entry_feature(tensor_X, tensor_label, tensor_probabilities);
}

void unifiedModelWrapper(const float tensor_X[1][3293], int64_t tensor_label[1], float tensor_probabilities[1][1]) {
	// entry_unified_model(tensor_X, tensor_label, tensor_probabilities);
}

void importModelWrapper(const float tensor_input[1][997], int64_t tensor_label[1], float tensor_output[1][1]) {
	entry_imports(tensor_input, tensor_output);
	tensor_output[0][0] = (float)logitToProbability(tensor_output[0][0]);
	if (tensor_output[0][0] > 0.5) {
		tensor_label[0] = MC_MALWARE;
	}
	else {
		tensor_label[0] = MC_BENIGN;
	}
}

void combineModelWrapper(const float tensor_X[1][2], int64_t tensor_label[1], float tensor_probabilities[1][1]) {
	combined_model_entry(tensor_X, tensor_label, tensor_probabilities);
	/*if (tensor_probabilities[0][0] > 0.5) {
		std::cout << "malware "  << std::endl;
	}
	else {
		std::cout << "benign" << std::endl;
	}
	std::cout << tensor_label[0] << std::endl;*/
}

void entry_multi_classification_wrapper(const float tensor_X[1][2197], int64_t tensor_label[1], float tensor_probabilities[1][8]) {
	//entry_multi_classification(tensor_X, tensor_label, tensor_probabilities);
}

//import model combined model feature model onnx
int __declspec(dllexport) OnnxToCConversion(struct PEImgDetails* data) {//
	if (data != NULL) {

		if (data->verified) {
			mcAnalysisDetailsSetter(data, 0.0, 0.0, 0.0, MC_BENIGN);
			return MC_BENIGN;
		}


		float feature_model[1][2224];
		int64_t feature_output_label[1] = { 0 };
		float feature_output_probability[1][1] = { 0 };
		float import_model[1][997];
		int64_t tensor_label[1] = { 0 };
		float tensor_probabilities[1][8] = { 0 };

		int isValidImport = 0;

		for (int i = 0; i < 2224; ++i) {  
			feature_model[0][i] = data->fullFeatureArr[i];
		}

		// we are planning to set a threshhold on no. of imports set in import feature array. if it is less than that treshhold, we need not come to import model
		int validImportFunctionCounter = 0;
		for (int i = 0; i < 997; i++) {
			import_model[0][i] = data->impFeatureArr[i];
			if (data->impFeatureArr[i] && i != 938) {
				isValidImport = 1;
			}
			if (data->impFeatureArr[i] != 0) {
				validImportFunctionCounter++;
			}
		}
		if (validImportFunctionCounter < 6) {
			isValidImport = 0;
		}


		featureModelWrapper(feature_model, feature_output_label, feature_output_probability);


		if (isValidImport) {
			int64_t import_output_label[1] = { 0 };
			float import_output_probability[1][1] = { 0 };
			importModelWrapper(import_model, import_output_label, import_output_probability);

			int64_t final_output_label[1] = { 0 };
			float final_output_probability[1][1] = { 0 };

			float combine_model_input[1][2] = { 0 };
			combine_model_input[0][0] = feature_output_probability[0][0];
			combine_model_input[0][1] = import_output_probability[0][0];

			combineModelWrapper(combine_model_input, final_output_label, final_output_probability);
			//printf("Combined Model Result is : %d and conf is : %f\n", final_output_label[0], final_output_probability[0][0]);

			data->mcAnalysis.combineprob = final_output_probability[0][0];

			if (final_output_probability[0][0] > 0.9)
			{

				if ((combine_model_input[0][0] < 0.5 || combine_model_input[0][1] < 0.5)) {
					//LOG(Log, "Marked as benign reason, Feature Model < 0.5 and Import Model < 0.5 and combine Model > 0.9 case {} ", data->filePath);
					mcAnalysisDetailsSetter(data, feature_output_probability[0][0], import_output_probability[0][0], final_output_probability[0][0], MC_BENIGN);
					return MC_BENIGN;
				}
				mcAnalysisDetailsSetter(data, feature_output_probability[0][0], import_output_probability[0][0], final_output_probability[0][0], MC_MALWARE);
				return MC_MALWARE;
			}
			else {
				if ((combine_model_input[0][0] > 0.9 && combine_model_input[0][1] > 0.9)) {
					//LOG(Log, "Marked as Malware Feature Model > 0.9 and Import Model > 0.9 and combine Model < 0.5 case {} ", data->filePath);
					mcAnalysisDetailsSetter(data, feature_output_probability[0][0], import_output_probability[0][0], final_output_probability[0][0], MC_MALWARE);
					return MC_MALWARE;
				}
				mcAnalysisDetailsSetter(data, feature_output_probability[0][0], import_output_probability[0][0], final_output_probability[0][0], MC_BENIGN);
				return MC_BENIGN;
			}
			mcAnalysisDetailsSetter(data, feature_output_probability[0][0], import_output_probability[0][0], final_output_probability[0][0], MC_BENIGN);
			return MC_BENIGN;
		}
		else {
			data->mcAnalysis.combineprob = feature_output_probability[0][0];
			if (feature_output_probability[0][0] >= 0.80) {
				mcAnalysisDetailsSetter(data, feature_output_probability[0][0], 0.0, feature_output_probability[0][0], MC_MALWARE);
				return MC_MALWARE;
			}
			mcAnalysisDetailsSetter(data, feature_output_probability[0][0], 0.0, feature_output_probability[0][0], MC_BENIGN);
			return MC_BENIGN;
		}
	}
	else {
		return MC_UNKNOWN;
	}
}


