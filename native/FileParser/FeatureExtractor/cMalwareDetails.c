#include "FeatureHeader.h"

double rt_log2(double x)
{
	return log2of10 * log10(x);
}

__declspec(noinline) long double entropy(uint64_t* prob) {
	uint64_t frequencies[256] = { 0 };

	uint64_t contentSize = 0;
	for (int i = 0; i < 256; i++) {
		contentSize += prob[i];
	}

	long double entropy = 0.0;
	for (uint64_t p = 0; p < 256; p++) {
		uint64_t a = prob[p];
		if (a > 0) {
			long double	 freq = (double)a / (double)contentSize;
			entropy += freq * log2l(freq);
		}
	}

	return (-entropy);
}

__declspec(noinline)   uint64_t alignA(uint64_t value, uint64_t align_on) {

	if (align_on == 0) {
		return value;
	}
	uint64_t r = value % align_on;
	if (r > 0) {
		return value + (align_on - r);
	}
	return value;
}

__declspec(noinline)  char* substring(char* destination, const char* source, int beg, int n)
{
	/*	.rdata,
	. => 1
	r => 1
	d => 1
	a => 2,
	t => 1  */
	// Extract `n` characters from the `source` char to `destination` char from the `beg`	
	while (n > 0)
	{
		*destination = *(source + beg);

		destination++;
		source++;
		n--;
	}
	// null at the end of char
	*destination = '\0';

	return destination;
}

__declspec(noinline)  unsigned int Rva2Offset(int64_t noOfSection, unsigned int rva, char* sections) {
	int64_t i;
	for (i = 0; i < noOfSection; i++) {
		IMAGE_SECTION_HEADER* sectionsIterate = (IMAGE_SECTION_HEADER*)(sections + (int64_t)((int64_t)i * (int64_t)IMAGE_SIZEOF_SECTION_HEADER));
		unsigned int x = sectionsIterate->VirtualAddress + sectionsIterate->SizeOfRawData;

		//To check which section the RVA falls into
		if (x >= rva) {
			//calculate the file offset 
			return rva - sectionsIterate->VirtualAddress + sectionsIterate->PointerToRawData;
		}
	}

	return -1;
}

__declspec(noinline)  void getHashFeatures(struct FeatNode* importFunList, float  importHashArray[1024], struct FeatNode* importLibararyList, float  libHashArray[256], float* fullFeatureArr)
{
	if (importFunList != NULL) {
		featureHasher(importFunList, 1024, importHashArray);
	}
	if (importLibararyList != NULL) {
		featureHasher(importLibararyList, 256, libHashArray);
	}
	for (int i = 0; i < 256; i++)
		fullFeatureArr[582 + i] = libHashArray[i];

	for (int i = 0; i < 1024; i++)
		fullFeatureArr[582 + 256 + i] = importHashArray[i];
}

__declspec(noinline) void importListToString(struct FeatNode* importFunctionList, size_t funnamelen, struct PEImgDetails* data) {
	struct FeatNode* last = importFunctionList;
	if (last != NULL) {
		data->importFunctionString = (char*)calloc(1, funnamelen);
	}
	while (last != NULL) {

		char* key = last->key;
		if (data->importFunctionString) {
			strcat(data->importFunctionString, key);
		}
		last = last->next;
		if (last != NULL) {
			if (data->importFunctionString) {
				strcat(data->importFunctionString, ",");
			}
		}
	}
}

__declspec(noinline)  struct FeatNode* collectMC(FILE* fp, struct PEImgDetails* data, int* isEXE
) {
	float* fullFeatureArr = data->fullFeatureArr;
	// collect all the feature details for both x32 and x64 
	*isEXE = 1;
	float exportFeaturesArray[128] = { 0 };		//	Exported Hash Array
	char* dllName = NULL;
	char* sections = NULL;
	IMAGE_DOS_HEADER dosHeader;
	WORD peFileType;
	int64_t numOfSection = 0;
	uint64_t size = 0;
	IMAGE_SECTION_HEADER* PEFILE_SECTION_HEADERS = NULL;

	/* HEADER INFO VARIABLEs */
	float charHashArray[10] = { 0 };
	float machineHashArray[10] = { 0 };
	struct FeatNode* machineList = NULL;
	struct FeatNode* charHeaderList = NULL;

	// OPTIONAL HEADER INFO VARIABLEs
	float magicHashArray[10] = { 0 };
	float subsystemHashArray[10] = { 0 };
	float dllHashArray[10] = { 0 };
	struct FeatNode* magicList = NULL;
	struct FeatNode* subsystemList = NULL;
	struct FeatNode* dllList = NULL;

	// PE SECTION INFO
	float sizeHashArray[50] = { 0 };
	float entropyHashArray[50] = { 0 };
	float vsizeHashArray[50] = { 0 };
	float entryHashArray[50] = { 0 };
	float characteristicsHashArray[50] = { 0 };
	float sectionSize = 0, sectionName = 0, sectionRX = 0; int  sectionW = 0;
	struct FeatNode* sizesList = NULL;
	struct FeatNode* vSizeList = NULL;
	struct FeatNode* entryList = NULL;
	struct FeatNode* entropyList = NULL;
	struct FeatNode* characteristicsList = NULL;
	struct FeatNode* implist = NULL;
	int firstSection = 0;
	int MEM_EXECUTE_FLAG = 0;
	int MEM_READ_FLAG = 0;

	// PEDATA DIRECTORIES INFO VARIABLEs
	size_t funnamelen = 0;

	// EXPORT DIRECTORY RVA
	DWORD exportDirectoryRVA = 0;
	struct FeatNode* exportList = NULL;

	// IMPORT DIRECTORY 
	struct FeatNode* importLibararyList = NULL;
	struct FeatNode* importFunList = NULL;
	//node_t* importFunName = NULL; 
	float libHashArray[256] = { 0 };
	float importHashArray[1024] = { 0 };

	if (fp == NULL) {
		printf("Error mapping view of file: NULL\n");
		goto cleanup;
	}

	long fileSize = data->fileSize;
	fullFeatureArr[256] = (float)fileSize;

	// getHistogramFeat(fileSize, fp, fullFeatureArr, data); // move to fileparser


	// READ DOSHEADER VALUE
	if (freadW(&dosHeader, 0, sizeof(IMAGE_DOS_HEADER), 1, fp, fileSize) != 1) {
		*isEXE = 0;
		goto cleanup;
	}
	// new check
	if (23117 != (int)dosHeader.e_magic) {
		*isEXE = 0;
		goto cleanup;
	}


	size += dosHeader.e_lfanew; // File address of new exe header
	size += sizeof(IMAGE_FILE_HEADER);


	// GET MAGIC BYTE
	if (freadW(&peFileType, (dosHeader.e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER)), sizeof(WORD), 1, fp, fileSize) != 1) {
		*isEXE = 0;
		goto cleanup;
	}

	// 32-BIT EXE
	if (peFileType == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
		size += sizeof(IMAGE_OPTIONAL_HEADER32);
		IMAGE_NT_HEADERS32 fileHeader;
		DWORD thunk = 0;
		PIMAGE_SECTION_HEADER importSection = NULL;

		if (freadW(&fileHeader, dosHeader.e_lfanew, sizeof(IMAGE_NT_HEADERS32), 1, fp, fileSize) != 1)
			goto cleanup;
		numOfSection = fileHeader.FileHeader.NumberOfSections;
		sections = (char*)calloc(numOfSection * IMAGE_SIZEOF_SECTION_HEADER, sizeof(char));
		exportDirectoryRVA = fileHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		DWORD importDirectoryRVA =
			fileHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
			.VirtualAddress;


		if (freadW(sections, (dosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS32)), (numOfSection * IMAGE_SIZEOF_SECTION_HEADER), 1, fp, fileSize) != 1){
			*isEXE = 0;
			goto cleanup;
		}

		for (int64_t i = 0; i < numOfSection; i++) {
			MEM_EXECUTE_FLAG = 0;
			MEM_READ_FLAG = 0;
			UINT64 prob[256] = { 0 };

			PEFILE_SECTION_HEADERS = (IMAGE_SECTION_HEADER*)(sections + (i * IMAGE_SIZEOF_SECTION_HEADER));



			size = maxA(size, (uint64_t)PEFILE_SECTION_HEADERS->VirtualAddress + PEFILE_SECTION_HEADERS->SizeOfRawData);
			size = (alignA(size, fileHeader.OptionalHeader.SectionAlignment));
			searchInsertFeatNode(&sizesList, (char*)PEFILE_SECTION_HEADERS->Name, (float)PEFILE_SECTION_HEADERS->SizeOfRawData);
			sectionCharData(&characteristicsList, PEFILE_SECTION_HEADERS->Characteristics, &MEM_READ_FLAG, &MEM_EXECUTE_FLAG, &sectionW, firstSection);
			if (MEM_EXECUTE_FLAG && MEM_READ_FLAG)
				sectionRX++;
			if (!firstSection)
			{
				char destination[2] = "";
				size_t lenSource = strlen((char*)PEFILE_SECTION_HEADERS->Name);

				for (size_t i = 0; i < lenSource; i++) {
					substring(destination, (const char*)PEFILE_SECTION_HEADERS->Name, (int)i, 1);
					searchInsertFeatNode(&entryList, destination, 1.0);
					firstSection++;
				}
			}
			searchInsertFeatNode(&vSizeList, (char*)PEFILE_SECTION_HEADERS->Name, (float)PEFILE_SECTION_HEADERS->Misc.VirtualSize);
			if (PEFILE_SECTION_HEADERS->SizeOfRawData == 0)
				sectionSize++;
			if (strlen((char*)PEFILE_SECTION_HEADERS->Name) == 0)
				sectionName++;

			// ENTROPY DETAILS 
			char* entropyValue = (char*)calloc(PEFILE_SECTION_HEADERS->SizeOfRawData, sizeof(char));




			if (freadW(entropyValue, PEFILE_SECTION_HEADERS->PointerToRawData, PEFILE_SECTION_HEADERS->SizeOfRawData, 1, fp, fileSize) != 1) {
				if (entropyValue)
					free(entropyValue);
				continue;
			}

			for (DWORD i = 0; i < PEFILE_SECTION_HEADERS->SizeOfRawData; i++) {

				prob[(UINT8)entropyValue[i]]++;

			}
			searchInsertFeatNode(&entropyList, (char*)PEFILE_SECTION_HEADERS->Name, (float)entropy(prob));
			if (importDirectoryRVA >= PEFILE_SECTION_HEADERS->VirtualAddress &&
				importDirectoryRVA < PEFILE_SECTION_HEADERS->VirtualAddress +
				PEFILE_SECTION_HEADERS->Misc.VirtualSize) {
				importSection = (PIMAGE_SECTION_HEADER)(sections + (i * IMAGE_SIZEOF_SECTION_HEADER));
			}
			if (entropyValue)
				free(entropyValue);
		}

		fullFeatureArr[327 + 0] = (float)numOfSection;
		fullFeatureArr[327 + 1] = (float)sectionSize;
		fullFeatureArr[327 + 2] = (float)sectionName;
		fullFeatureArr[327 + 3] = (float)sectionRX;
		fullFeatureArr[327 + 4] = (float)sectionW;
		featureHasher(sizesList, 50, sizeHashArray);
		featureHasher(vSizeList, 50, vsizeHashArray);
		featureHasher(entryList, 50, entryHashArray);
		featureHasher(characteristicsList, 50, characteristicsHashArray);
		featureHasher(entropyList, 50, entropyHashArray);

		int debug = fileHeader.OptionalHeader.DataDirectory[6].VirtualAddress;
		fullFeatureArr[256 + 2] = (float)((debug > 0) ? 1.0 : 0.0);									// 2 - TWO
		int relocation = fileHeader.OptionalHeader.DataDirectory[5].VirtualAddress;
		fullFeatureArr[256 + 5] = (float)(relocation > 0 ? 1.0 : 0.0);
		int res = fileHeader.OptionalHeader.DataDirectory[2].VirtualAddress;
		fullFeatureArr[256 + 6] = (float)(res > 0 ? 1.0 : 0.0);
		int tls = fileHeader.OptionalHeader.DataDirectory[9].VirtualAddress;
		fullFeatureArr[256 + 8] = (float)(tls > 0 ? 1.0 : 0.0);
		int sign = fileHeader.OptionalHeader.DataDirectory[4].VirtualAddress;
		fullFeatureArr[256 + 7] = (float)(sign > 0 ? 1.0 : 0.0);
		fullFeatureArr[256 + 9] = (float)(fileHeader.FileHeader.PointerToSymbolTable > 0 ? 1.0 : 0.0);


		/* HEADER INFO VARIABLEs */
		machineHashData(&machineList, fileHeader.FileHeader.Machine);
		if (machineList != NULL) {
			featureHasher(machineList, 10, machineHashArray);
		}
		charHashData(&charHeaderList, fileHeader.FileHeader.Characteristics);
		if (charHeaderList != NULL) {
			featureHasher(charHeaderList, 10, charHashArray);
		}
		INT64 time = (INT64)fileHeader.FileHeader.TimeDateStamp;
		float timeStamp = (float)time;
		//fullFeatureArr[266 + 0] = timeStamp;
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[265 + 11 + i] = charHashArray[i];
			fullFeatureArr[265 + 1 + i] = machineHashArray[i];
		}

		/* OPTIONAL HEADER VARIABLEs */
		magicMapData(&magicList, fileHeader.OptionalHeader.Magic);
		if (magicList != NULL) {
			featureHasher(magicList, 10, magicHashArray);
		}
		subSystemMapData(&subsystemList, fileHeader.OptionalHeader.Subsystem);
		if (subsystemList != NULL) {
			featureHasher(subsystemList, 10, subsystemHashArray);
		}
		dllMapData(&dllList, fileHeader.OptionalHeader.DllCharacteristics);
		if (dllList != NULL) {
			featureHasher(dllList, 10, dllHashArray);
		}
		fullFeatureArr[286 + 30] = (float)fileHeader.OptionalHeader.MajorImageVersion;
		fullFeatureArr[286 + 31] = (float)fileHeader.OptionalHeader.MinorImageVersion;
		fullFeatureArr[286 + 32] = (float)fileHeader.OptionalHeader.MajorLinkerVersion;
		fullFeatureArr[286 + 33] = (float)fileHeader.OptionalHeader.MinorLinkerVersion;
		fullFeatureArr[286 + 34] = (float)fileHeader.OptionalHeader.MajorOperatingSystemVersion;
		fullFeatureArr[286 + 35] = (float)fileHeader.OptionalHeader.MinorOperatingSystemVersion;
		fullFeatureArr[286 + 36] = (float)fileHeader.OptionalHeader.MajorSubsystemVersion;
		fullFeatureArr[286 + 37] = (float)fileHeader.OptionalHeader.MinorSubsystemVersion;
		fullFeatureArr[286 + 38] = (float)fileHeader.OptionalHeader.SizeOfCode;
		fullFeatureArr[286 + 39] = (float)fileHeader.OptionalHeader.SizeOfHeaders;
		fullFeatureArr[286 + 40] = (float)fileHeader.OptionalHeader.SizeOfHeapCommit;

		for (int i = 0; i < 10; i++) {
			fullFeatureArr[286 + i] = subsystemHashArray[i];
		}
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[286 + 10 + i] = dllHashArray[i];
		}
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[286 + 20 + i] = magicHashArray[i];
		}


		/* DATA DIRECTORY VARIABLEs */
		for (DWORD i = 0; i < fileHeader.OptionalHeader.NumberOfRvaAndSizes; i++) {

			if (i < 15) {

				fullFeatureArr[1990 + 2 * i] = (float)fileHeader.OptionalHeader.DataDirectory[i].Size;
				fullFeatureArr[1990 + 2 * i + 1] = (float)fileHeader.OptionalHeader.DataDirectory[i].VirtualAddress;
			}
			else {
				break;
			}
		}

		/* IMPORT FUNCITON DETAILS */
		if (importSection == NULL) {
			fullFeatureArr[256 + 4] = 0;
			goto cleanup;
		}
		int importFunCount = 0;
		DWORD _import_directory_address = importSection->PointerToRawData;
		int _import_directory_count = 0;



		while (TRUE) {
			IMAGE_IMPORT_DESCRIPTOR importDescriptor;
			int offset =
				(_import_directory_count * sizeof(IMAGE_IMPORT_DESCRIPTOR)) +
				_import_directory_address +
				(fileHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
					.VirtualAddress -
					importSection->VirtualAddress);

			if (freadW(&importDescriptor, offset, sizeof(IMAGE_IMPORT_DESCRIPTOR), 1, fp, fileSize) != 1) {
				break;
			}

			if (importDescriptor.Name == 0x00000000 &&
				importDescriptor.FirstThunk == 0x00000000) {
				_import_directory_count -= 1;
				break;
			}
			PIMAGE_THUNK_DATA thunkData = NULL;

			int dllNameLen = 100;
			dllName = (char*)calloc(dllNameLen, sizeof(char));
			while (freadW(dllName, (size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress), dllNameLen, 1, fp, fileSize) != 1) {
				if ((dllNameLen + (size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) > fileSize) {
					dllNameLen = fileSize - ((size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) - 1;
					if (dllName) {
						free(dllName);
						dllName = NULL;
					}
					if (dllNameLen < 0 || dllNameLen > fileSize || (importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) > fileSize || (importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) + dllNameLen > fileSize)
						goto cleanup;

					dllName = (char*)calloc(dllNameLen, sizeof(char));
				}
			}

			searchInsertFeatNode(&importLibararyList, dllName, 1.0);
			thunk = importDescriptor.OriginalFirstThunk == 0
				? importDescriptor.FirstThunk
				: importDescriptor.OriginalFirstThunk;
			if (thunk == 0) {
				_import_directory_count++;
				continue;
			}

			int thunkCount = 0;
			uint64_t checkThunkTempDataAddress = 0;
			while (1) {
				IMAGE_THUNK_DATA32 thunkTempData;

				if (freadW(&thunkTempData, (size_t)((size_t)importSection->PointerToRawData + (size_t)thunk - importSection->VirtualAddress + (sizeof(IMAGE_THUNK_DATA32) * thunkCount)), sizeof(IMAGE_THUNK_DATA32), 1, fp, fileSize) != 1)
					goto cleanup;

				if (thunkTempData.u1.AddressOfData == checkThunkTempDataAddress) {
					break;
				}
				checkThunkTempDataAddress = thunkTempData.u1.AddressOfData;
				if (thunkTempData.u1.AddressOfData == 0) {
					break;
				}
				if (thunkTempData.u1.AddressOfData >= 0x80000000) {
					importFunCount++;
					char* funValue = (char*)calloc(strlen("") + strlen(dllName) + 10, sizeof(char));
					strncat(funValue, dllName, strlen(dllName));
					strncat(funValue, ":", 1);
					strncat(funValue, "", strlen(""));
					searchInsertFeatNodeN(&importFunList, funValue, 1.0);
					funnamelen += strlen(funValue);
					funnamelen += 1;
					if (funValue)
						free(funValue);
				}

				else {
					int funNamelen = 1000;
					char* funName = (char*)calloc(funNamelen, sizeof(char));
					while (freadW(funName, (size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2, funNamelen, 1, fp, fileSize) != 1) {
						if ((funNamelen + (size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2) > fileSize) {
							funNamelen = fileSize - ((importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress) + 2) - 1;
							if (funName)
								free(funName);
							if (funNamelen<0 || funNamelen> fileSize || (importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2) > fileSize || (importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2) + funNamelen > fileSize) {
								goto cleanup;
							}
							funName = (char*)calloc(funNamelen, sizeof(char));
						}
					}
					importFunCount++;


					searchInsertFeatNode(&implist,
						funName,
						1.0);
					char* funValue = (char*)calloc(strlen(funName) + strlen(dllName) + 10, sizeof(char));

					strncat(funValue, dllName, strlen(dllName));
					strncat(funValue, ":", 1);
					strncat(funValue, funName, strlen(funName));
					searchInsertFeatNodeN(&importFunList, funValue, 1.0);
					//printf("%s \n", funValue);
					funnamelen += strlen(funValue);
					funnamelen += 1;

					if (funName)
						free(funName);
					if (funValue)
						free(funValue);


				}

				thunkCount++;
			}

			_import_directory_count++;

			if (dllName) {
				free(dllName);
				dllName = NULL;
			}

		}


		fullFeatureArr[256 + 4] = (float)importFunCount;

		if (importFunList != NULL) {
			featureHasher(importFunList, 1024, importHashArray);
		}
		if (importLibararyList != NULL) {
			featureHasher(importLibararyList, 256, libHashArray);
		}
		for (int i = 0; i < 256; i++)
			fullFeatureArr[582 + i] = libHashArray[i];

		for (int i = 0; i < 1024; i++)
			fullFeatureArr[582 + 256 + i] = importHashArray[i];

	}

	// 64-BIT EXE
	else if (peFileType == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
		DWORD thunk = 0;
		size += sizeof(IMAGE_OPTIONAL_HEADER64);
		IMAGE_NT_HEADERS64 fileHeader;
		IMAGE_THUNK_DATA64* thunkData = NULL;
		PIMAGE_SECTION_HEADER importSection = NULL;


		if (freadW(&fileHeader, dosHeader.e_lfanew, sizeof(IMAGE_NT_HEADERS64), 1, fp, fileSize) != 1) {
			*isEXE = 0;
			goto cleanup;
		}

		numOfSection = fileHeader.FileHeader.NumberOfSections;
		sections = (char*)calloc(numOfSection * IMAGE_SIZEOF_SECTION_HEADER, sizeof(char));
		exportDirectoryRVA = fileHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
		DWORD importDirectoryRVA =
			fileHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
			.VirtualAddress;
		if (freadW(sections, (dosHeader.e_lfanew + sizeof(IMAGE_NT_HEADERS64)), ((numOfSection)*IMAGE_SIZEOF_SECTION_HEADER), 1, fp, fileSize) != 1) {
			*isEXE = 0;
			goto cleanup;
		}

		for (int64_t i = 0; i < numOfSection; i++) {
			MEM_EXECUTE_FLAG = 0;
			MEM_READ_FLAG = 0;
			UINT64 prob[256] = { 0 };
			PEFILE_SECTION_HEADERS = (IMAGE_SECTION_HEADER*)(sections + (i * IMAGE_SIZEOF_SECTION_HEADER));
			size = maxA(size, (uint64_t)PEFILE_SECTION_HEADERS->VirtualAddress + PEFILE_SECTION_HEADERS->SizeOfRawData);
			size = (alignA(size, fileHeader.OptionalHeader.SectionAlignment));

			searchInsertFeatNode(&sizesList, (char*)PEFILE_SECTION_HEADERS->Name, (float)PEFILE_SECTION_HEADERS->SizeOfRawData);
			if (PEFILE_SECTION_HEADERS->SizeOfRawData == 0)
				sectionSize++;
			sectionCharData(&characteristicsList, PEFILE_SECTION_HEADERS->Characteristics, &MEM_READ_FLAG, &MEM_EXECUTE_FLAG, &sectionW, firstSection);
			if (MEM_EXECUTE_FLAG && MEM_READ_FLAG)
				sectionRX++;
			if (!firstSection)
			{
				char destination[2] = "";
				size_t lenSource = strlen((char*)PEFILE_SECTION_HEADERS->Name);
				for (size_t i = 0; i < lenSource; i++) {
					substring(destination, (const char*)PEFILE_SECTION_HEADERS->Name, (int)i, 1);
					searchInsertFeatNode(&entryList, destination, 1.0);
					firstSection++;
				}
			}
			searchInsertFeatNode(&vSizeList, (char*)PEFILE_SECTION_HEADERS->Name, (float)PEFILE_SECTION_HEADERS->Misc.VirtualSize);
			if (strlen(PEFILE_SECTION_HEADERS->Name) == 0) {
				sectionName++;
			}

			// ENTROPY DETAILS
			if ((long)PEFILE_SECTION_HEADERS->SizeOfRawData > fileSize) {
				continue;
			}
			char* entropyValue = (char*)calloc(PEFILE_SECTION_HEADERS->SizeOfRawData, sizeof(char));
			if (freadW(entropyValue, PEFILE_SECTION_HEADERS->PointerToRawData, PEFILE_SECTION_HEADERS->SizeOfRawData, 1, fp, fileSize) != 1) {
				if (entropyValue)
					free(entropyValue);
				continue;
			}

			for (int i = 0; i < (int)PEFILE_SECTION_HEADERS->SizeOfRawData; i++) {
				prob[(UINT8)entropyValue[i]]++;
			}
			searchInsertFeatNode(&entropyList, (char*)PEFILE_SECTION_HEADERS->Name, (float)entropy(prob));
			if (importDirectoryRVA >= PEFILE_SECTION_HEADERS->VirtualAddress &&
				importDirectoryRVA < PEFILE_SECTION_HEADERS->VirtualAddress +
				PEFILE_SECTION_HEADERS->Misc.VirtualSize) {
				importSection = (PIMAGE_SECTION_HEADER)(sections + (i * IMAGE_SIZEOF_SECTION_HEADER));
			}

			if (entropyValue)
				free(entropyValue);

		}

		fullFeatureArr[327 + 0] = (float)numOfSection;
		fullFeatureArr[327 + 1] = (float)sectionSize;
		fullFeatureArr[327 + 2] = (float)sectionName;
		fullFeatureArr[327 + 3] = (float)sectionRX;
		fullFeatureArr[327 + 4] = (float)sectionW;
		featureHasher(sizesList, 50, sizeHashArray);
		featureHasher(vSizeList, 50, vsizeHashArray);
		featureHasher(entryList, 50, entryHashArray);
		featureHasher(characteristicsList, 50, characteristicsHashArray);
		featureHasher(entropyList, 50, entropyHashArray);


		int debug = fileHeader.OptionalHeader.DataDirectory[6].VirtualAddress;
		fullFeatureArr[256 + 2] = (float)((debug > 0) ? 1.0 : 0.0);
		int relocation = fileHeader.OptionalHeader.DataDirectory[5].VirtualAddress;
		fullFeatureArr[256 + 5] = (float)(relocation > 0 ? 1.0 : 0.0);
		int res = fileHeader.OptionalHeader.DataDirectory[2].VirtualAddress;
		fullFeatureArr[256 + 6] = (float)(res > 0 ? 1.0 : 0.0);
		int tls = fileHeader.OptionalHeader.DataDirectory[9].VirtualAddress;
		fullFeatureArr[256 + 8] = (float)(tls > 0 ? 1.0 : 0.0);
		int sign = fileHeader.OptionalHeader.DataDirectory[4].VirtualAddress;
		fullFeatureArr[256 + 7] = (float)(sign > 0 ? 1.0 : 0.0);
		fullFeatureArr[256 + 9] = (float)(fileHeader.FileHeader.PointerToSymbolTable > 0 ? 1.0 : 0.0);

		machineHashData(&machineList, fileHeader.FileHeader.Machine);
		if (machineList != NULL) {
			featureHasher(machineList, 10, machineHashArray);
		}
		charHashData(&charHeaderList, fileHeader.FileHeader.Characteristics);
		if (charHeaderList != NULL) {
			featureHasher(charHeaderList, 10, charHashArray);
		}
		INT64 time = (INT64)fileHeader.FileHeader.TimeDateStamp;
		float timeStamp = (float)time;

		//fullFeatureArr[266 + 0] = timeStamp;
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[265 + 11 + i] = charHashArray[i];
			fullFeatureArr[265 + 1 + i] = machineHashArray[i];
		}

		magicMapData(&magicList, fileHeader.OptionalHeader.Magic);
		if (magicList != NULL) {
			featureHasher(magicList, 10, magicHashArray);
		}
		subSystemMapData(&subsystemList, fileHeader.OptionalHeader.Subsystem);
		if (subsystemList != NULL) {
			featureHasher(subsystemList, 10, subsystemHashArray);
		}
		dllMapData(&dllList, fileHeader.OptionalHeader.DllCharacteristics);
		if (dllList != NULL) {
			featureHasher(dllList, 10, dllHashArray);
		}
		fullFeatureArr[286 + 30] = (float)fileHeader.OptionalHeader.MajorImageVersion;
		fullFeatureArr[286 + 31] = (float)fileHeader.OptionalHeader.MinorImageVersion;
		fullFeatureArr[286 + 32] = (float)fileHeader.OptionalHeader.MajorLinkerVersion;
		fullFeatureArr[286 + 33] = (float)fileHeader.OptionalHeader.MinorLinkerVersion;
		fullFeatureArr[286 + 34] = (float)fileHeader.OptionalHeader.MajorOperatingSystemVersion;
		fullFeatureArr[286 + 35] = (float)fileHeader.OptionalHeader.MinorOperatingSystemVersion;
		fullFeatureArr[286 + 36] = (float)fileHeader.OptionalHeader.MajorSubsystemVersion;
		fullFeatureArr[286 + 37] = (float)fileHeader.OptionalHeader.MinorSubsystemVersion;
		fullFeatureArr[286 + 38] = (float)fileHeader.OptionalHeader.SizeOfCode;
		fullFeatureArr[286 + 39] = (float)fileHeader.OptionalHeader.SizeOfHeaders;
		fullFeatureArr[286 + 40] = (float)fileHeader.OptionalHeader.SizeOfHeapCommit;
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[286 + i] = subsystemHashArray[i];
		}
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[286 + 10 + i] = dllHashArray[i];
		}
		for (int i = 0; i < 10; i++) {
			fullFeatureArr[286 + 20 + i] = magicHashArray[i];
		}
		for (DWORD i = 0; i < fileHeader.OptionalHeader.NumberOfRvaAndSizes; i++) {
			if (i < 15) {
				fullFeatureArr[1990 + 2 * i] = (float)fileHeader.OptionalHeader.DataDirectory[i].Size;
				fullFeatureArr[1990 + 2 * i + 1] = (float)fileHeader.OptionalHeader.DataDirectory[i].VirtualAddress;
			}
		}

		/* IMPORT FUNCTION */
		if (importSection == NULL) {
			fullFeatureArr[256 + 4] = 0;
			goto cleanup;
		}
		DWORD _import_directory_address = importSection->PointerToRawData;
		int _import_directory_count = 0;
		int importFunCount = 0;

		while (TRUE) {
			IMAGE_IMPORT_DESCRIPTOR importDescriptor;
			int offset =
				(_import_directory_count * sizeof(IMAGE_IMPORT_DESCRIPTOR)) +
				_import_directory_address +
				(fileHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]
					.VirtualAddress -
					importSection->VirtualAddress);
			//printf("offset %d \t filesize %d\n", offset, fileSize);
			if (freadW(&importDescriptor, offset, sizeof(IMAGE_IMPORT_DESCRIPTOR), 1, fp, fileSize) != 1) {
				//goto cleanup;
				break;
			}

			if (importDescriptor.Name == 0x00000000 &&
				importDescriptor.FirstThunk == 0x00000000) {
				_import_directory_count -= 1;
				break;
			}
			PIMAGE_THUNK_DATA thunkData = NULL;

			//STATIC DLL Name
			int dllNameLen = 100;
			 dllName = (char*)calloc(dllNameLen, sizeof(char));
			while (freadW(dllName, (size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress), dllNameLen, 1, fp, fileSize) != 1) {
				//printf("%d\t %d\t %d\n", (size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress), fileSize , dllNameLen);
				if ((dllNameLen + (size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) > fileSize) {
					dllNameLen = fileSize - ((size_t)importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) - 1;
					if (dllName) {
						free(dllName);
						dllName = NULL;
					}
					if (dllNameLen < 0 || dllNameLen > fileSize || (importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) > fileSize || dllNameLen + (importSection->PointerToRawData + (size_t)(importDescriptor.Name - importSection->VirtualAddress)) > fileSize)
						goto cleanup;

					dllName = (char*)calloc(dllNameLen, sizeof(char));
				}
			}


			searchInsertFeatNode(&importLibararyList, dllName, 1.0);

			thunk = importDescriptor.OriginalFirstThunk == 0
				? importDescriptor.FirstThunk
				: importDescriptor.OriginalFirstThunk;

			if (thunk == 0) {
				_import_directory_count++;
				continue;
			}
			int thunkCount = 0;
			uint64_t checkThunkTempDataAddress = 0;
			while (1) {
				IMAGE_THUNK_DATA64 thunkTempData;
				if (freadW(&thunkTempData, ((size_t)importSection->PointerToRawData + ((size_t)thunk - importSection->VirtualAddress) + ((sizeof(IMAGE_THUNK_DATA64) * thunkCount))), sizeof(IMAGE_THUNK_DATA64), 1, fp, fileSize) != 1)
					goto cleanup;


				if (thunkTempData.u1.AddressOfData == checkThunkTempDataAddress) {
					break;
				}
				checkThunkTempDataAddress = thunkTempData.u1.AddressOfData;
				if (thunkTempData.u1.AddressOfData == 0) {
					break;
				}
				if (thunkTempData.u1.AddressOfData >= 0x80000000) {
					importFunCount++;
					char* funValue = (char*)calloc(strlen("") + strlen(dllName) + 10, sizeof(char));
					strncat(funValue, dllName, strlen(dllName));
					strncat(funValue, ":", 1);
					strncat(funValue, "", strlen(""));
					searchInsertFeatNodeN(&importFunList, funValue, 1.0);
					funnamelen += strlen(funValue);
					funnamelen += 1;

					if (funValue)
						free(funValue);
				}
				else {
					size_t funNamelen = 1000;
					char* funName = (char*)calloc(funNamelen, sizeof(char));
					while (freadW(funName, (size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2, funNamelen, 1, fp, fileSize) != 1) {
						if ((funNamelen + (size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2) > fileSize) {
							if (funName)
								free(funName);
							funNamelen = fileSize - (size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + (size_t)2;
							if (funNamelen<0 || funNamelen > fileSize || ((size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + (size_t)2 + funNamelen) > fileSize || ((size_t)importSection->PointerToRawData + (size_t)thunkTempData.u1.AddressOfData - (size_t)importSection->VirtualAddress + 2) > fileSize) {
								goto cleanup;
							}
							funName = (char*)calloc(funNamelen, sizeof(char));
						}
					}

					importFunCount++;
					//printf("%s\n", funName);
					searchInsertFeatNode(&implist, funName, 1.0);

					char* funValue = (char*)calloc(strlen(funName) + strlen(dllName) + 10, sizeof(char));

					strncat(funValue, dllName, strlen(dllName));
					strncat(funValue, ":", 1);
					strncat(funValue, funName, strlen(funName));
					searchInsertFeatNodeN(&importFunList, funValue, 1.0);
					//printf("%s \n", funValue);
					funnamelen += strlen(funValue);
					funnamelen += 1;

					if (funName)
						free(funName);
					if (funValue)
						free(funValue);
				}
				thunkCount++;
			}
			_import_directory_count++;
			if (dllName) {
				free(dllName);
				dllName = NULL;
			}
		}


		fullFeatureArr[256 + 4] = (float)importFunCount;

		getHashFeatures(importFunList, importHashArray, importLibararyList, libHashArray, fullFeatureArr);


	}

	// OTHER
	else {
		*isEXE = 0;
		goto cleanup;
	}

	// EXPORT INFO
	if (exportDirectoryRVA <= 0)
		goto cleanup;
	unsigned int export_offset = Rva2Offset(numOfSection, exportDirectoryRVA, sections);
	if (export_offset < 1)
		goto cleanup;

	//Getting number of exported API
	unsigned int numberOfAPIName = 0;
	if (freadW(&numberOfAPIName, (size_t)export_offset + 0x18, 4, 1, fp, fileSize) != 1)
		goto cleanup;

	//Get the RVA of the EXPORT Array of API
	DWORD pointer_to_exportName_RVA;
	if (freadW(&pointer_to_exportName_RVA, (size_t)((size_t)export_offset + (size_t)0x20), 4, 1, fp, fileSize) != 1)
		goto cleanup;

	if (pointer_to_exportName_RVA <= 0) {
		goto cleanup;
	}

	//Get the fp offset from the RVA of EXPORT array pointer
	unsigned int export_name_array_offset = Rva2Offset(numOfSection, pointer_to_exportName_RVA, sections);
	DWORD pointerToArrayRVA;

	//Read the RVA to Array 
	if (freadW(&pointerToArrayRVA, export_name_array_offset, 4, 1, fp, fileSize) != 1)
		goto cleanup;


	//Read the Actual fp offset of the array
	unsigned int offsetToFirstAddressOfAPIArray = Rva2Offset(numOfSection, pointerToArrayRVA, sections);


	size_t arrayOffset = 0;
	//printf("export function count %d\n", numberOfAPIName);
	if (numberOfAPIName > 200 || (long)offsetToFirstAddressOfAPIArray > fileSize) {
		goto cleanup;
	}
	fullFeatureArr[256 + 3] = (float)numberOfAPIName;
	for (int i = 1; i <= (int)numberOfAPIName; i++) {
		
		size_t szNameLen = 1000;
		char* szName = (char*)calloc(szNameLen, sizeof(char));
		while (freadW(szName, (size_t)offsetToFirstAddressOfAPIArray + (size_t)arrayOffset, szNameLen, 1, fp, fileSize) != 1) {
			if ((szNameLen + (size_t)offsetToFirstAddressOfAPIArray + (size_t)arrayOffset) > fileSize) {
				szNameLen = fileSize - (size_t)offsetToFirstAddressOfAPIArray + (size_t)arrayOffset;
				if (szName)
					free(szName);
				if (szNameLen < 0 || szNameLen > fileSize || ((size_t)offsetToFirstAddressOfAPIArray + (size_t)arrayOffset) > fileSize || ((size_t)offsetToFirstAddressOfAPIArray + (size_t)arrayOffset) + szNameLen > fileSize) {
					goto cleanup;
				}
				szName = (char*)calloc(szNameLen, sizeof(char));
				//printf("%s \n", szName);
				if (!szName) {
					fprintf(stderr, "Memory allocation failed for szName\n");
					goto cleanup;
				}
			}
		}
		szName[szNameLen - 1] = '\0';
		szNameLen = strlen(szName) + 1;

		searchInsertFeatNode(&exportList, szName, 1.0);
		if (szName)
			free(szName);
		arrayOffset += szNameLen;
	}
	featureHasher(exportList, 128, exportFeaturesArray);
	for (int i = 0; i < 128; i++) {
		fullFeatureArr[1862 + i] = exportFeaturesArray[i];
	}

cleanup:
	if (dllName) {
		free(dllName);
	}
	importListToString(importFunList, funnamelen, data);

	fullFeatureArr[256 + 1] = (float)size;						// 1 - ONE
	for (int i = 0; i < 50; i++) {
		fullFeatureArr[327 + 5 + i] = sizeHashArray[i];
		fullFeatureArr[327 + 55 + i] = entropyHashArray[i];
		fullFeatureArr[327 + 105 + i] = vsizeHashArray[i];
		fullFeatureArr[327 + 155 + i] = entryHashArray[i];
		fullFeatureArr[327 + 205 + i] = characteristicsHashArray[i];
	}
	if (*isEXE == 0) {
		for (int i = 0; i < 2224; i++) {
			fullFeatureArr[i] = 0;
		}
	}

	if (sections)
		free(sections);
	if (characteristicsList)
		freeFeatNode(characteristicsList);
	if (dllList)
		freeFeatNode(dllList);
	if (charHeaderList)
		freeFeatNode(charHeaderList);
	if (subsystemList)
		freeFeatNode(subsystemList);
	if (machineList)
		freeFeatNode(machineList);
	if (magicList)
		freeFeatNode(magicList);
	if (vSizeList)
		freeFeatNode(vSizeList);
	if (sizesList)
		freeFeatNode(sizesList);
	if (exportList)
		freeFeatNode(exportList);
	if (entryList)
		freeFeatNode(entryList);
	if (entropyList)
		freeFeatNode(entropyList);
	if (importLibararyList)
		freeFeatNode(importLibararyList);
	if (importFunList)
		freeFeatNode(importFunList);
	return implist;
}

